
(Hui神LC视屏讲解)[https://m.youtube.com/user/wisdompeak/videos]  
(1000道LC答案)[https://www.cnblogs.com/grandyang/p/4606334.html]

**排序类（Sort）：**

- 基础知识：快速排序（Quick Sort）， 归并排序（Merge Sort）的原理与代码实现。需要能讲明白代码中每一行的目的。快速排序时间复杂度平均状态下O（NlogN），空间复杂度O（1），归并排序最坏情况下时间复杂度O（NlogN），空间复杂度O（N）

- 入门题目：

- - Leetcode 148. Sort List
  - Leetcode 56. Merge Intervals
  - Leetcode 27. Remove elements

- 进阶题目：

- - Leetcode 179. Largest Number
  - Leetcode 75. Sort Colors
  - Leetcode 215. Kth Largest Element （可以用堆的解法替代）
  - Leetcode 4. Median of Two Sorted Arrays

注意：后两题是与快速排序非常相似的快速选择（Quick Select）算法，面试中很常考

**链表类（Linked List）：**

- 基础知识：链表如何实现，如何遍历链表。链表可以保证头部尾部插入删除操作都是O（1），查找任意元素位置O（N）

- 基础题目：

- - Leetcode 206. Reverse Linked List
  - Leetcode 876. Middle of the Linked List

注意：快慢指针和链表反转几乎是所有链表类问题的基础，尤其是反转链表，代码很短，建议直接背熟。

- 进阶题目:

- - Leetcode 160. Intersection of Two Linked Lists
  - Leetcode 141. Linked List Cycle (Linked List Cycle II)
  - Leetcode 92. Reverse Linked List II
  - Leetcode 328. Odd Even Linked List

**堆（Heap or Priority Queue）、栈（Stack）、队列（Queue）、哈希表类（Hashmap、Hashset）：**

- 基础知识：各个数据结构的基本原理，增删查改复杂度。

- Queue题目：

- - Leetcode 225. Implement Stack using Queues
  - Leetcode 346. Moving Average from Data Stream
  - Leetcode 281. Zigzag Iterator
  - Leetcode 1429. First Unique Number
  - Leetcode 54. Spiral Matrix
  - Leetcode 362. Design Hit Counter

- Stack题目：

- - Leetcode 155. Min Stack (follow up Leetcode 716 Max Stack)
  - Leetcode 232. Implement Queue using Stacks
  - Leetcode 150. Evaluate Reverse Polish Notation
  - Leetcode 224. Basic Calculator II (I, II, III, IV)
  - Leetcode 20. Valid Parentheses
  - Leetcode 1472. Design Browser History
  - Leetcode 1209. Remove All Adjacent Duplicates in String II
  - Leetcode 1249. Minimum Remove to Make Valid Parentheses
  - Leetcode 735. Asteroid Collision

- Hashmap/ Hashset题目：

- - Leetcode 1. Two Sum
  - Leetcode 146. LRU Cache (Python中可以使用OrderedDict来代替)
  - Leetcode 128. Longest Consecutive Sequence
  - Leetcode 73. Set Matrix Zeroes
  - Leetcode 380. Insert Delete GetRandom O(1)
  - Leetcode 49. Group Anagrams
  - Leetcode 350. Intersection of Two Arrays II
  - Leetcode 299. Bulls and Cows
  - Leetcode 348 Design Tic-Tac-Toe

- Heap／Priority Queue题目：

- - Leetcode 973. K Closest Points
  - Leetcode 347. Top k Largest Elements
  - Leetcode 23. Merge K Sorted Lists
  - Leetcode 264. Ugly Number II
  - Leetcode 1086. High Five
  - Leetcode 88. Merge Sorted Arrays
  - Leetcode 692. Top K Frequent Words
  - Leetcode 378. Kth Smallest Element in a Sorted Matrix
  - Leetcode 295. Find Median from Data Stream （标准解法是双heap，但是SortedDict会非常容易）
  - Leetcode 767. Reorganize String
  - Leetcode 1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit (这个题用单调双端队列、TreeMap、双heap都可以)
  - Leetcode 895. Maximum Frequency Stack

**二分法（Binary Search）：**

- 基础知识：二分法是用来解法基本模板，时间复杂度logN；常见的二分法题目可以分为两大类，显式与隐式，即是否能从字面上一眼看出二分法的特点：要查找的数据是否可以分为两部分，前半部分为X，后半部分为O

- 显式二分法：

- - Leetcode 34. Find First and Last Position of Element in Sorted Array
  - Leetcode 33. Search in Rotated Sorted Array
  - Leetcode 1095. Find in Mountain Array
  - Leetcode 162. Find Peak Element
  - Leetcode 278. First Bad Version
  - Leetcode 74. Search a 2D Matrix
  - Leetcode 240. Search a 2D Matrix II

- 隐式二分法：

- - Leetcode 69. Sqrt(x)
  - Leetcode 540. Single Element in a Sorted Array
  - Leetcode 644. Maximum Average Subarray II
  - Leetcode 528. Random Pick with Weight
  - Leetcode 1300. Sum of Mutated Array Closest to Target
  - Leetcode 1060. Missing Element in Sorted Array
  - Leetcode 1062. Longest Repeating Substring
  - Leetcode 1891. Cutting Ribbons

**双指针（2 Pointer）：**

- 基础知识：常见双指针算法分为三类，同向（即两个指针都相同一个方向移动），背向（两个指针从相同或者相邻的位置出发，背向移动直到其中一根指针到达边界为止），相向（两个指针从两边出发一起向中间移动直到两个指针相遇）

- 背向双指针：(基本上全是回文串的题)

- - Leetcode 409. Longest Palindrome
  - Leetcode 125. Valid Palindrome
  - Leetcode 5. Longest Palindromic Substring
  - Leetcode 647. Palindromic Substrings

- 相向双指针：(以two sum为基础的一系列题)

- - Leetcode 1. Two Sum (这里使用的是先排序的双指针算法，不同于hashmap做法)
  - Leetcode 167. Two Sum II - Input array is sorted
  - Leetcode 15. 3Sum
  - Leetcode 16. 3Sum Closest
  - Leetcode 18. 4Sum
  - Leetcode 454. 4Sum II
  - Leetcode 277. Find the Celebrity
  - Leetcode 11. Container With Most Water

- 同向双指针：（个人觉得最难的一类题，可以参考下这里 [TimothyL：Leetcode 同向双指针/滑动窗口类代码模板](https://zhuanlan.zhihu.com/p/390570255)）

- - Leetcode 283. Move Zeroes
  - Leetcode 26. Remove Duplicate Numbers in Array
  - Leetcode 395. Longest Substring with At Least K Repeating Characters
  - Leetcode 340. Longest Substring with At Most K Distinct Characters
  - Leetcode 424. Longest Repeating Character Replacement
  - Leetcode 76. Minimum Window Substring
  - Leetcode 3. Longest Substring Without Repeating Characters
  - Leetcode 1004 Max Consecutive Ones III

**宽度优先搜索（BFS）：**面试中最常考的

- 基础知识：

- - 常见的BFS用来解决什么问题？(1) 简单图（有向无向皆可）的最短路径长度，注意是长度而不是具体的路径（2）拓扑排序 （3） 遍历一个图（或者树）

- BFS基本模板（需要记录层数或者不需要记录层数）

- 多数情况下时间复杂度空间复杂度都是O（N+M），N为节点个数，M为边的个数

- 基于树的BFS：不需要专门一个set来记录访问过的节点

- - Leetcode 102 Binary Tree Level Order Traversal
  - Leetcode 103 Binary Tree Zigzag Level Order Traversal
  - Leetcode 297 Serialize and Deserialize Binary Tree （很好的BFS和双指针结合的题）
  - Leetcode 314 Binary Tree Vertical Order Traversal

- 基于图的BFS：（一般需要一个set来记录访问过的节点）

- - Leetcode 200. Number of Islands
  - Leetcode 133. Clone Graph
  - Leetcode 127. Word Ladder
  - Leetcode 490. The Maze
  - Leetcode 323. Connected Component in Undirected Graph
  - Leetcode 130. Surrounded Regions
  - Leetcode 752. Open the Lock
  - Leetcode 815. Bus Routes
  - Leetcode 1091. Shortest Path in Binary Matrix
  - Leetcode 542. 01 Matrix
  - Leetcode 1293. Shortest Path in a Grid with Obstacles Elimination
  - Leetcode 417. Pacific Atlantic Water Flow

- 拓扑排序：（[https://zh.wikipedia.org/wiki/%E6%8B%93%E6%92%B2%E6%8E%92%E5%BA%8F](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E6%8B%93%E6%92%B2%E6%8E%92%E5%BA%8F)）

- - Leetcode 207 Course Schedule （I, II）
  - Leetcode 444 Sequence Reconstruction
  - Leetcode 269 Alien Dictionary
  - Leetcode 310 Minimum Height Trees
  - Leetcode 366 Find Leaves of Binary Tree

**深度优先搜索（DFS）：**面试中最常考的（分类的稍微有点粗糙了，没有细分出回溯/分治来，准备找个时间给每个DFS的题标记下是哪种DFS）

- 基础知识：

- - 常见的DFS用来解决什么问题？(1) 图中（有向无向皆可）的符合某种特征（比如最长）的路径以及长度（2）排列组合（3） 遍历一个图（或者树）（4）找出图或者树中符合题目要求的全部方案
  - DFS基本模板（需要记录路径，不需要返回值 and 不需要记录路径，但需要记录某些特征的返回值）
  - 除了遍历之外多数情况下时间复杂度是指数级别，一般是O(方案数×找到每个方案的时间复杂度)
  - 递归题目都可以用非递归迭代的方法写，但一般实现起来非常麻烦

- 基于树的DFS：需要记住递归写前序中序后序遍历二叉树的模板

- - Leetcode 543 Diameter of Binary Tree (分治)
  - Leetcode 124 Binary Tree Maximum Path Sum (分治)
  - Leetcode 226 Invert Binary Tree (分治)[https://leetcode.com/problems/invert-binary-tree/description/]
```c++

/**
 * 2022-04-25 @realChrisChen
 * 分治法
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(!root)
        {
            return nullptr;
        }
        TreeNode* tmp = root->left;
        root->left = invertTree(root->right);
        root->right = invertTree(tmp);
        return root;
        
    }
};
```
  - Leetcode 101 Symmetric Tree (回溯 or 分治)[https://leetcode.com/problems/symmetric-tree/description/]
```c++
/**
 * 2022-04-25 @realChrisChen
 * 分治法
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        return Syn(root,root);
    }
    
    bool Syn(TreeNode* A, TreeNode* B)
    {
        if(!A || !B ) return A == B;        //A为空或者B为空时，我就判断A和B是否同时为空，A和B能直接判断相等也就只有A和B同时为空才行
/*等同于
          if(!A || !B) return false;
          if(!A && !B) return true;
        
*/    
        if(A->val != B->val) return false;                     //两个节点值不相等那肯定就不对称
        return Syn(A->left, B->right) && Syn(A->right,B->left);//当 A左 = B右 且 A右 = B左 返回
    }
};
```
  - Leetcode 951 Flip Equivalent Binary Trees (分治)[https://leetcode.com/problems/flip-equivalent-binary-trees/description/]
```c++

/**
 * 2022-04-25 @realChrisChen
 * 分治法
 */
class Solution {
public:
    bool flipEquiv(TreeNode* root1, TreeNode* root2) {
        if (!root1 && !root2) return true;
        if (!root1 || !root2 || root1->val != root2->val) return false;
        return (flipEquiv(root1->left, root2->left) && flipEquiv(root1->right, root2->right)) || (flipEquiv(root1->left, root2->right) && flipEquiv(root1->right, root2->left));
    }
};
```
  - Leetcode 236 Lowest Common Ancestor of a Binary Tree (相似题：235、1650) (回溯 or 分治)[https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/]
```c++
/**
 * 2022-04-26 @realChrisChen
 * 分治法
 */
class Solution 
{
    TreeNode* ret = nullptr;
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) 
    {
        int a = dfs(root,p,q);
        return ret;
    }
    
    
    int dfs(TreeNode* root, TreeNode* p, TreeNode* q)
    {
        if(root == nullptr) return 0;
        int left = dfs(root->left, p, q);
        int right = dfs(root->right, p, q);
        int self = (root == p || root ==q);
        int count = left + right + self;
        if(count == 2 && ret == nullptr)
        {
            ret =root;
        }
        return count;
    }
};



```
  - Leetcode 235 Lowest Common Ancestor of a Binary Search Tree(分治)[https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/]
```c++
/**
 * 2022-04-26 @realChrisChen
 * 分治法
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!root)
            return nullptr;
        if(p->val < root->val && q->val < root->val)
            return lowestCommonAncestor(root->left, p, q);
        else if(p->val > root->val && q->val > root->val)
            return lowestCommonAncestor(root->right, p, q);
        else
            return root;
    };
};



```
  - Leetcode 105 Construct Binary Tree from Preorder and Inorder Traversal (分治)[https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/]

```c++
/**
 * 2022-04-26 @realChrisChen
 * 分治法
 */
 class Solution {
public:
    TreeNode *buildTree(vector<int> &preorder, vector<int> &inorder) {
        return buildTree(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1);
    }
    TreeNode *buildTree(vector<int> &preorder, int pLeft, int pRight, vector<int> &inorder, int iLeft, int iRight) {
        //边界条件
        if (pLeft > pRight || iLeft > iRight) 
            return nullptr;
        //找到root在中序排列数组中的位置
        int i = 0;
        for (i = iLeft; i <= iRight; ++i) {
            if (preorder[pLeft] == inorder[i]) break;
        }
        //建立root
        TreeNode *cur = new TreeNode(preorder[pLeft]);
        //建立左子树
        cur->left = buildTree(preorder, pLeft+1, pLeft+i-iLeft,inorder,iLeft, i-1);
        //建立右子树
        cur->right = buildTree(preorder, pLeft+i-iLeft+1, pRight, inorder, i+1,iRight);
        //返回root
        return cur;

    }
};



```
  - Leetcode 104 Maximum Depth of Binary Tree (回溯 or 分治)[https://leetcode.com/problems/maximum-depth-of-binary-tree/description/]

```c++
/**
 * 2022-04-26 @realChrisChen
 * 分治法
 */
class Solution {
int depth = 0;
public:
    int maxDepth(TreeNode* root) {
        if(root == nullptr)
            return depth;
        int left = maxDepth(root->left);
        int right = maxDepth(root->right);
        return 1+( right > left ? right : left);
    }
};

```
  - Leetcode 987 Vertical Order Traversal of a Binary Tree[https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/]
```c++
/**
 * 2022-04-27 @realChrisChen
 * 分治法
 */
class Solution {
public:
    vector<vector<int>> verticalTraversal(TreeNode* root) {
        vector<vector<int>> res;
        map<int, map<int, vector<int>>> m;
        helper(root, 0, 0, m);
        for (auto &a : m) {
            vector<int> col;
            for (auto &it : a.second) {
                sort(it.second.begin(), it.second.end());
                col.insert(col.end(), it.second.begin(), it.second.end());
            }
            res.push_back(col);
        }
        return res;
    }
    void helper(TreeNode* root, int x, int y, map<int, map<int, vector<int>>>& m) {
        if (!root) return;
        m[x][y].push_back(root->val);
        helper(root->left, x - 1, y + 1, m);
        helper(root->right, x + 1, y + 1, m);
    }
};



```
  
  - Leetcode 572 Subtree of Another Tree (分治)[https://leetcode.com/problems/subtree-of-another-tree/description/]
```c++
/**
 * 2022-04-27 @realChrisChen
 * 分治法
 */
class Solution {
public:
    bool isSubtree(TreeNode* s, TreeNode* t) 
    {
    
        if(!s)
            return false;
        if(isSame(s,t))
            return true;
        return isSubtree(s->left, t) || isSubtree(s->right,t);
            
    
    }
    
    bool isSame(TreeNode* s, TreeNode* t)
    {
        if(!s && !t)
            return true;
        if(!s || !t)
            return false;
        if(s->val != t->val)
            return false;
        return isSame(s->left,t->left) && isSame(s->right, t->right);
        
    }
};

```
  - Leetcode 863 All Nodes Distance K in Binary Tree[https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/description/]

```c++
/**
 * 2022-04-27 @realChrisChen
 * 分治法
 */
class Solution {
public:
    vector<int> distanceK(TreeNode* root, TreeNode* target, int K) {
    	if (!root) return {};
        vector<int> res;
        unordered_map<TreeNode*, TreeNode*> parent;
        unordered_set<TreeNode*> visited;
        findParent(root, parent);
        helper(target, K, parent, visited, res);
        return res;
    }
    void findParent(TreeNode* node, unordered_map<TreeNode*, TreeNode*>& parent) {
    	if (!node) return;
    	if (node->left) parent[node->left] = node;
    	if (node->right) parent[node->right] = node;
    	findParent(node->left, parent);
    	findParent(node->right, parent);
    }
    void helper(TreeNode* node, int K, unordered_map<TreeNode*, TreeNode*>& parent, unordered_set<TreeNode*>& visited, vector<int>& res) {
    	if (visited.count(node)) return;
    	visited.insert(node);
    	if (K == 0) {res.push_back(node->val); return;}
    	if (node->left) helper(node->left, K - 1, parent, visited, res);
    	if (node->right) helper(node->right, K - 1, parent, visited, res);
    	if (parent[node]) helper(parent[node], K - 1, parent, visited, res);
    }
};

```
  - Leetcode 1110 Delete Nodes And Return Forest (分治)[https://leetcode.com/problems/delete-nodes-and-return-forest/description/]
```c++
/**
 * 2022-04-28 @realChrisChen
 * 分治法
 */
class Solution {
public:
    vector<TreeNode*> delNodes(TreeNode* root, vector<int>& to_delete) {
        vector<TreeNode*> res;
        unordered_set<int> st(to_delete.begin(), to_delete.end());
        helper(root, true, st, res);
        return res;
    }
    TreeNode* helper(TreeNode* node, bool is_root, unordered_set<int>& st, vector<TreeNode*>& res) {
        if (!node) return nullptr;
        bool deleted = st.count(node->val);
        if (is_root && !deleted) res.push_back(node);
        node->left = helper(node->left, deleted, st, res);
        node->right = helper(node->right, deleted, st, res);
        return deleted ? nullptr : node;
    }
};
 
```
- ($$$)Leetcode 1485 Clone Binary Tree With Random Pointer

- 二叉搜索树（BST）：BST特征：中序遍历为单调递增的二叉树，换句话说，根节点的值比左子树任意节点值都大，比右子树任意节点值都小，增删查改均为O（h）复杂度，h为树的高度；注意不是所有的BST题目都需要递归，有的题目只需要while循环即可
---
- - Leetcode 230 Kth Smallest element in a BST[https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/]
```c++
/**
 * 2022-04-29 @realChrisChen
 * 分治法
 */
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        int count = cnt(root->left);
        
        if(k <= count)
            return kthSmallest(root->left,k);
        else if(k > count+1)
            return kthSmallest(root->right,k-count-1);
        else 
            return root->val;
       
    }
    
    int cnt(TreeNode* node)
    {
        if(!node)
            return 0;
        return 1+cnt(node->left)+cnt(node->right);
    }
};



```
  - Leetcode 98 Validate Binary Search Tree[https://leetcode.com/problems/validate-binary-search-tree/]

```c++
/**
 * 2022-04-29 @realChrisChen
 * 递归+带入初始值
 */

class Solution {
public:
    bool isValidBST(TreeNode* root) {
        return isValidBST(root, LONG_MIN, LONG_MAX);
    }
    bool isValidBST(TreeNode* root, long mn, long mx) {
        if (!root) return true;
        if (root->val <= mn || root->val >= mx) return false;
        return isValidBST(root->left, mn, root->val) && isValidBST(root->right, root->val, mx);
    }
};

```
  - ($$$)Leetcode 270 Cloest Binary Search Tree Value

  - (REPEAT)Leetcode 235 Lowest Common Ancestor of a Binary Search Tree

```c++
/**
 * 2022-04-29 @realChrisChen
 * 分治法
 */

class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!root)
            return nullptr;
        if(p->val < root->val && q->val < root->val)
            return lowestCommonAncestor(root->left, p, q);
        else if(p->val > root->val && q->val > root->val)
            return lowestCommonAncestor(root->right, p, q);
        else
            return root;
    };
};


```
  - Leetcode 669 Trim a Binary Search Tree (分治)[https://leetcode.com/problems/trim-a-binary-search-tree/description/]
```c++
/**
 * 2022-04-29 @realChrisChen
 * 分治法
 */
class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int L, int R) {
        if (!root) return NULL;
        //如果节点值小于最低界限的话，直接去看其右子树
        if (root->val < L) return trimBST(root->right, L, R);
        //如果节点值大于最大界限的话，直接去看其左子树
        if (root->val > R) return trimBST(root->left, L, R);
        //更新左子树
        root->left = trimBST(root->left, L, R);
        //更新右子树
        root->right = trimBST(root->right, L, R);
        //base case: 返回节点
        return root;
    }
};
```
---
---
  - Leetcode 700 Search in a Binary Search Tree[https://leetcode.com/problems/search-in-a-binary-search-tree/description/]
```c++
/**
 * 2022-04-30 @realChrisChen
 * 分治法
 */
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if(!root)
            return nullptr;
        if(val == root->val)
            return root;
        else if(val < root->val)
            return searchBST(root->left, val);
        else
            return searchBST(root->right,val);
    }
};
```
  - Leetcode 108 Convert Sorted Array to inary Search Tree (分治)[https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/]
```c++
/**
 * 2022-04-30 @realChrisChen
 * 二分查找
 */

class Solution {
public:
    TreeNode* sortedArrayToBST(vector<int>& nums)
    {
        return helper(nums, 0, (int)nums.size()-1);
    }
    TreeNode* helper(vector<int>& nums, int left, int right) 
    {
        if(left > right) 
            return nullptr;
        int mid = left + (right - left) / 2;
        TreeNode* cur = new TreeNode(nums[mid]);
        cur->left = helper(nums, left, mid-1);
        cur->right = helper(nums,mid+1, right);
        return cur;
    }
};

```
  - ($$$)Leetcode 333 Largest BST Subtree (与98类似) (分治)



  - ($$$)Leetcode 285 Inorder Successor in BST (I, II)

---
- 基于图的DFS: 和BFS一样一般需要一个set来记录访问过的节点，避免重复访问造成死循环; Word XXX 系列面试中非常常见，例如word break，word ladder，word pattern，word search。

- - Leetcode 341 Flatten Nested List Iterator (339 364)[https://leetcode.com/problems/flatten-nested-list-iterator/description/]
```c++
/**
 * 2022-04-30 @realChrisChen
 * 
 */
class NestedIterator {
public:
    NestedIterator(vector<NestedInteger> &nestedList) {
        for (int i = nestedList.size() - 1; i >= 0; --i) {
            s.push(nestedList[i]);
        }
    }

    int next() {
        NestedInteger t = s.top(); s.pop();
        return t.getInteger();
    }

    bool hasNext() {
        while (!s.empty()) {
            NestedInteger t = s.top(); 
            if (t.isInteger()) return true;
            s.pop();
            for (int i = t.getList().size() - 1; i >= 0; --i) {
                s.push(t.getList()[i]);
            }
        }
        return false;
    }
private:
    stack<NestedInteger> s;
};

```
---
  - Leetcode 394 Decode String[https://www.cnblogs.com/grandyang/p/4606334.html]
```c++
/**
 * 2022-05-01 @realChrisChen
 * 
 */

class Solution {
public:
    string decodeString(string s) {
        int i = 0;
        return decode(s, i);
    }
    string decode(string s, int& i) {//这里必须是传入引用，如果不是引用的话，跳过'['这一步的修改无法传出来
        string res = "";
        int n = s.size();
        //当序列号小于字符串长度时，序列号对应值不等于']'，循环
        while (i < n && s[i] != ']') {
            //当序列号值不等于数字时，直接加入res空字符串
            if (s[i] < '0' || s[i] > '9') {
                res += s[i++];
            } else {
            
                int cnt = 0;
                //当序列号值等于数字时，将后面所有能连接的数字连接起来并转换成真正的数字
                while (s[i] >= '0' && s[i] <= '9') {
                    cnt = cnt * 10 + s[i++] - '0';
                }
                ++i;
                
                //跳过'['
                string t = decode(s, i);
                
                //倍数相加内容
                while (cnt-- > 0) {
                    res += t;
                }
                
                ++i;
            }
        }
        return res;
    }
};

```
  - Leetcode 51 N-Queens (I II基本相同)[https://leetcode.com/problems/n-queens/description/]
```c++
/**
 * 2022-05-01 @realChrisChen
 * 
 */



class Solution {
    vector<vector<string>>results;
    vector<string>board;    
    int n;
public:
    vector<vector<string>>solveNQueens(int n) 
    {     
        this->n = n;           
        string s(n,'.');
        for (int i=0; i<n; i++)
            board.push_back(s);
                
        DFS(0);
        return results;
    }
    
    void DFS(int i)
    {                        
        if (i==n)
        {
            results.push_back(board);
            return;
        }
        for (int j=0; j<n; j++)
        {
            if (isValid(i,j))
            {
                board[i][j]='Q';
                DFS(i+1);
                board[i][j]='.';
            }                
        }        
    }
    
    bool isValid(int row, int col)
    {
        for (int i=0; i<row; i++)
            if (board[i][col]=='Q') return false;
        for (int j=0; j<col; j++)
            if (board[row][j]=='Q') return false;
        int k=1;
        while (row-k >= 0 && col-k >= 0)
        {
            if (board[row-k][col-k]=='Q') return false;
            k++;
        }
        k=1;
        while (row-k >= 0 && col+k < n)
        {
            if (board[row-k][col+k]=='Q') return false;
            k++;
        }
        return true;
    }
};


```
  - ($$$)Leetcode 291 Word Pattern II (I为简单的Hashmap题)
  - Leetcode 126 Word Ladder II （I为BFS题目)[https://leetcode.com/problems/word-ladder-ii/description/]
```c++
/**
 * 2022-05-01 @realChrisChen
 * 
 */
class Solution {
public:
    unordered_set<string>wordSet;
    unordered_map<string,vector<string>>next;
    unordered_map<string,unordered_set<string>>prev;
    vector<vector<string>>results;
    string beginWord;
    
    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) 
    {   
        wordList.push_back(beginWord);        
        
        for (auto str:wordList)
            wordSet.insert(str);
        this->beginWord = beginWord;
        
        if (wordSet.find(endWord)==wordSet.end()) return {};
                
        for (int i=0; i<wordList.size(); i++)
        {
            string str = wordList[i];
            for (int k=0; k<str.size(); k++)
            {                
                for (char ch='a'; ch<='z'; ch++)
                {
                    string temp = str;
                    temp[k] = ch;
                    if (temp==str) continue;
                    if (wordSet.find(temp)!=wordSet.end())
                        next[str].push_back(temp);                    
                }
            }
        }
        
        unordered_set<string>visited;
        queue<string>q;
        int flag = 0;
        
        q.push(beginWord);
        visited.insert(beginWord);
        
        while (!q.empty())
        {
            int len = q.size();
            unordered_set<string>newVisited;
            
            for (int k=0; k<len; k++)
            {
                string str = q.front();
                q.pop();
                                
                for (auto nextStr: next[str])
                {                                        
                    if (visited.find(nextStr)!=visited.end())
                        continue;                                                                                
                    prev[nextStr].insert(str);
                    newVisited.insert(nextStr);
                    
                    if (nextStr==endWord) flag = 1;
                }
            }    
            
            for (auto x: newVisited)
            {
                visited.insert(x);                
                q.push(x);
            }                
            
            if (flag==1) break;
        }       
        
        if (flag==0) return {};
        
        DFS(endWord,{endWord});
        
        return results;
    }
    
    void DFS(string word, vector<string> path)
    {
        if (word==beginWord)
        {
            reverse(path.begin(),path.end());
            results.push_back(path);
            return;
        }
        
        for (auto preStr:prev[word])
        {
            vector<string>newPath=path;
            newPath.push_back(preStr);
            DFS(preStr, newPath);
        }
        return;
    }
};

```
---
---
  - Leetcode 93 Restore IP Addresses[https://leetcode.com/problems/restore-ip-addresses]
```c++
/**
 * 2022-05-02 @realChrisChen
 * 回溯法
 */
class Solution {
public:
    vector<string> restoreIpAddresses(string s) {
        vector<string> res;
        restore(s, 4, "", res);
        return res;
    }
    void restore(string s, int k, string out, vector<string> &res) {
        if (k == 0) {
            if (s.empty()) res.push_back(out);
        }
        else {
            for (int i = 1; i <= 3; ++i) {
                if (s.size() >= i && isValid(s.substr(0, i))) {
                    if (k == 1) restore(s.substr(i), k - 1, out + s.substr(0, i), res);
                    else restore(s.substr(i), k - 1, out + s.substr(0, i) + ".", res);
                }
            }
        }
    }
    bool isValid(string s) {
        if (s.empty() || s.size() > 3 || (s.size() > 1 && s[0] == '0')) return false;
        int res = atoi(s.c_str());
        return res <= 255 && res >= 0;
    }
};


```
  - Leetcode 22 Generate Parentheses[https://leetcode.com/problems/generate-parentheses/description/]
```c++
/**
 * 2022-05-02 @realChrisChen
 * 分治
 */
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        vector<string> res;
        genPair(n,n,"",res);
        return res;
    }
    
    void genPair(int l, int r, string out, vector<string>& res)
    {
        if(l > r)
            return;
        if(r == 0 && l == 0)
        {
            res.push_back(out);
        }
        else
        {
            if(l > 0) genPair(l-1, r, out+"(", res);
            if(r > 0) genPair(l, r-1, out+")", res);
        }
                
    }

};


```
  - Leetcode 856 Score of Parentheses[https://leetcode.com/problems/score-of-parentheses/description/]
```c++
/**
 * 2022-05-02 @realChrisChen
 * 栈
 */
class Solution {
public:
    int scoreOfParentheses(string S) {
        int res = 0;
        stack<int> st;
        for (char c : S) 
        {
            if (c == '(') 
            {
                st.push(res);
                res = 0;
            }
            else 
            {
                res = st.top() + max(res * 2, 1); 
                st.pop();
            }
        }
        return res;
    }
};

```
  - Leetcode 301 Remove Invalid Parentheses[https://leetcode.com/problems/remove-invalid-parentheses/description/]
```c++
/**
 * 2022-05-02 @realChrisChen
 * 
 */
class Solution {
public:
    vector<string> removeInvalidParentheses(string s) 
    {
        vector<string> res;
        helper(s, 0, 0, {'(', ')'}, res);
        return res;
    }
    void helper(string s, int last_i, int last_j, vector<char> p, vector<string>& res) 
    {
        int cnt = 0;
        for (int i = last_i; i < s.size(); ++i) 
        {
            if (s[i] == p[0]) ++cnt;
            else if (s[i] == p[1]) --cnt;
            if (cnt >= 0) continue;
            for (int j = last_j; j <= i; ++j) 
            {
                if (s[j] == p[1] && (j == last_j || s[j] != s[j - 1])) 
                {
                    helper(s.substr(0, j) + s.substr(j + 1), i, j, p, res);
                }
            }
            return;
        }
        string rev = string(s.rbegin(), s.rend());
        if (p[0] == '(') helper(rev, 0, 0, {')', '('}, res);
        else res.push_back(rev);
    }
};


```
---
  - Leetcode 37 Sodoku Solver[https://www.youtube.com/watch?v=q63a2oDwmwM&ab_channel=HuifengGuan]

  - Leetcode 212 Word Search II （I, II）
  - Leetcode 1087 Brace Expansion
  - Leetcode 399 Evaluate Division
  - Leetcode 1274 Number of Ships in a Rectangle
  - Leetcode 1376 Time Needed to Inform All Employees
  - Leetcode 694 Number of Distinct Islands
  - Leetcode 131 Palindrome Partitioning

- 基于排列组合的DFS: 其实与图类DFS方法一致，但是排列组合的特征更明显

- - Leetcode 17 Letter Combinations of a Phone Number
  - Leetcode 39 Combination Sum（I, II, III相似， IV为动态规划题目）
  - Leetcode 78 Subsets （I, II 重点在于如何去重）
  - Leetcode 46 Permutation (I, II 重点在于如何去重)
  - Leetcode 77 Combinations (I, II 重点在于如何去重)
  - Leetcode 698 Partition to K Equal Sum Subsets
  - Leetcode 526 Beautiful Arrangement (similar to 46)

- 记忆化搜索（DFS + Memoization Search）：算是动态规划的一种，递归每次返回时同时记录下已访问过的节点特征，避免重复访问同一个节点，可以有效的把指数级别的DFS时间复杂度降为多项式级别; 注意这一类的DFS必须在最后有返回值，不可以用排列组合类型的DFS方法写; for循环的dp题目都可以用记忆化搜索的方式写，但是不是所有的记忆化搜索题目都可以用for循环的dp方式写。

- - Leetcode 139 Word Break II
  - Leetcode 72 Edit Distance
  - Leetcode 377 Combination Sum IV
  - Leetcode 1235 [Maximum Profit in Job Scheduling](https://link.zhihu.com/?target=https%3A//leetcode.com/explore/item/3950)
  - Leetcode 1335 Minimum Difficulty of a Job Schedule
  - Leetcode 1216 Valid Palindrome III
  - Leetcode 97 Interleaving String
  - Leetcode 472 Concatenated Words
  - Leetcode 403 Frog Jump
  - Leetcode 329 Longest Increasing Path in a Matrix

**前缀和（Prefix Sum）**

- 基础知识：前缀和本质上是在一个list当中，用O（N）的时间提前算好从第0个数字到第i个数字之和，在后续使用中可以在O（1）时间内计算出第i到第j个数字之和，一般很少单独作为一道题出现，而是很多题目中的用到的一个小技巧

- 常见题目：

- - Leetcode 53 Maximum Subarray
  - Leetcode 1423 Maximum Points You Can Obtain from Cards
  - Leetcode 1031 Maximum Sum of Two Non-Overlapping Subarrays
  - Leetcode 523 Continuous Subarray Sum
  - Leetcode 304 Range Sum Query 2D - Immutable

------

以上内容皆为面试中高频的知识点，以下知识点和题目在面试中属于中等频率（大概面10道题会遇到一次），时间不足的情况下，请以准备上面的知识点为主。

**并查集（Union Find）：把两个或者多个集合合并为一个集合**

- 基础知识：如果数据不是实时变化，本类问题可以用BFS或者DFS的方式遍历，如果数据实时变化（data stream）则并查集每次的时间复杂度可以视为O（1）；需要牢记合并与查找两个操作的模板

- 常见题目：

- - Leetcode 721 Accounts Merge
  - Leetcode 547 Number of Provinces
  - Leetcode 737 Sentence Similarity II
  - Leetcode 305 Number of Islands II

**字典树（Trie）**

- 基础知识：（[https://zh.wikipedia.org/wiki/Trie](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/Trie)）；多数情况下可以通过用一个set来记录所有单词的prefix来替代，时间复杂度不变，但空间复杂度略高

- 常见题目：

- - Leetcode 208 Implement Trie (Prefix Tree)
  - Leetcode 211 Design Add and Search Words Data Structure
  - Leetcode 1268 Search Suggestions System
  - Leetcode 212 Word Search II

**单调栈与单调队列（Monotone Stack／Queue）**

- 基础知识：单调栈一般用于解决数组中找出每个数字的第一个大于／小于该数字的位置或者数字；单调队列只见过一道题需要使用；不论单调栈还是单调队列，单调的意思是保留在栈或者队列中的数字是单调递增或者单调递减的

- 常见题目：

- - Leetcode 85 Maximum Rectangle
  - Leetcode 84 Largest Rectangle in Histogram
  - Leetcode 907 Sum of Subarray Minimums (与84类似)
  - Leetcode 739 Daily Temperatures
  - Leetcode 901 Online Stock Span
  - Leetcode 503 Next Greater Element II
  - Leetcode 239 Sliding Window Maximum （唯一的单调队列题）

**扫描线算法（Sweep Line）**

- 基础知识：一个很巧妙的解决时间安排冲突的算法，本身比较容易些也很容易理解

- 常见题目：

- - Leetcode 253 Meeting Room II（Meeting Room I也可以使用）
  - Leetcode 218 The Skyline Problem
  - Leetcode 759 Employee Free Time

**TreeMap**

- 基础知识：基于红黑树（平衡二叉搜索树）的一种树状 hashmap，增删查改、找求大最小均为logN复杂度，Python当中可以使用SortedDict替代；SortedDict继承了普通的dict全部的方法，除此之外还可以peekitem(k)来找key里面第k大的元素，popitem(k)来删除掉第k大的元素，弥补了Python自带的heapq没法logN时间复杂度内删除某个元素的缺陷；最近又在刷一些hard题目时候突然发现TreeMap简直是个神技，很多用别的数据结构写起来非常麻烦的题目，TreeMap解决起来易如反掌。
- 常见题目：
- Leetcode 729 My Calendar I
- Leetcode 981 Time Based Key-Value Store
- Leetcode 846 Hand of Straights
- Leetcode 218 The Skyline Problem
- Leetcode 480. Sliding Window Median (这个题用TreeMap超级方便)
- Leetcode 318 Count of Smaller Numbers After Self (这个题线段树、二分索引树、TreeMap都可以)

**动态规划（Dynamic Programming）**

- 基础知识：这里指的是用for循环方式的动态规划，非Memoization Search方式。DP可以在多项式时间复杂度内解决DFS需要指数级别的问题。常见的题目包括找最大最小，找可行性，找总方案数等，一般结果是一个Integer或者Boolean。动态规划有很多分支，暂时还没想好怎么去写这部分，后面想好了再具体写吧。

- 常见题目：

- - Leetcode 674 Longest Continuous Increasing Subsequence (接龙型dp)
  - Leetcode 62 Unique Paths II
  - Leetcode 70 Climbing Stairs
  - Leetcode 64 Minimum Path Sum
  - Leetcode 368 Largest Divisible Subset (接龙型dp)
  - Leetcode 300 Longest Increasing Subsequence (接龙型dp)
  - Leetcode 354 Russian Doll Envelopes (接龙型dp， 300的2D版)
  - Leetcode 256 Paint House
  - Leetcode 121 Best Time to Buy and Sell Stock
  - Leetcode 55 Jump Game
  - Leetcode 45 Jump Game II
  - Leetcode 132 Palindrome Partitioning II
  - Leetcode 312 Burst Balloons (区间型dp)
  - Leetcode 1143 Longest Common Subsequence (前缀型dp)
  - Leetcode 1062 Longest Repeating Substring (dp方法与longest common substring一致)
  - Leetcode 718 Maximum Length of Repeated Subarray (和1062本质上一样)
  - Leetcode 174 Dungeon Game
  - Leetcode 115 Distinct Subsequences
  - Leetcode 72 Edit Distance
  - Leetcode 91 Decode Ways
  - Leetcode 639 Decode Ways II
  - Leetcode 712 Minimum ASCII Delete Sum for Two Strings
  - Leetcode 221 Maximal Square
  - Leetcode 1277 Count Square Submatrices with All Ones (可以使用221一样的解法)
  - Leetcode 198 House Robber
  - Leetcode 213 House Robber II
  - Leetcode 740 Delete and Earn
  - Leetcode 87 Scramble String
  - Leetcode 1140 Stone Game II
  - Leetcode 322 Coin Change
  - Leetcode 518 Coin Change II (01背包型)
  - Leetcode 1048 Longest String Chain
  - Leetcode 44 [Wildcard Matching](https://link.zhihu.com/?target=https%3A//leetcode.com/problems/wildcard-matching)
  - Leetcode 10 [Regular Expression Matching](https://link.zhihu.com/?target=https%3A//leetcode.com/problems/regular-expression-matching)
  - Leetcode 32 Longest Valid Parentheses
  - Leetcode 1235 Maximum Profit in Job Scheduling (DP + binary search)
  - Leetcode 1043 Partition Array for Maximum Sum
  - Leetcode 926 Flip String to Monotone Increasing