---
layout: post
toc: true
title: "Leetcode三道题 - 二分法02"
categories: Code
tags: [Leetcode系列]
author:
  - Chris Chen
---



### <a href = "https://leetcode.com/problems/guess-number-higher-or-lower/description/">(E)374. Guess Number Higher or Lower</a>
```c++
class Solution {
public:
    int guessNumber(int n) 
    {
        //特殊情况处理，如果开始就直接猜到了，那就直接返回了
        if(guess(n) == 0) return n;
        int left = 1;
        int right = n - 1;
        while(left < right)
        {
            int mid = left + (right - left)/2;
            if(guess(mid) == 1) 
                left = mid + 1;
            else if(guess(mid) == 0)
                return mid;
            else
                right = mid;
        }
        return left;
    }
};
```


### <a href = "https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/">(M)1011. Capacity To Ship Packages Within D Days</a>
```c++
class Solution {
public:
   
    
    int shipWithinDays(vector<int>& weights, int days) 
    {
        //找到单个最大的
        int left = *max_element(weights.begin(), weights.end());
        //找到总重量
        int right = accumulate(weights.begin(), weights.end(), 0);
        
        while(left < right)
        {
            int mid = left + (right - left) / 2;
            /* 得出适合此重量的搬运天数 */
            //所需天数
            int cnt = 1;
            //当前重量
            int cur = 0;
            for(int w: weights)
            {
                cur += w;
                //当前重量超过了我就不增加天数了
                if(cur > mid)
                {
                    cur = w;
                    ++cnt;
                }
            }
            /*                       */


            //当天数大于所需天数时，说明重量还不够
            if(cnt > days)
                left = mid + 1;
            else
                right = mid;
             
        }
        return left; 
    }
};
```


### <a href = "https://leetcode.com/problems/find-smallest-letter-greater-than-target/description/">(E)744. Find Smallest Letter Greater Than Target</a>
```c++
class Solution {
public:
    char nextGreatestLetter(vector<char>& letters, char target)
    {
        if(target >= letters.back())
            return letters[0];
        int left = 0;
        int right = letters.size() - 1;
        while(left < right)
        {
            int mid = left + (right - left)/2;
            //想想这里为什么要用等于符号？可以将等于情况排除并继续向右查询
            if(target >= letters[mid])
                left = mid + 1;
            else
                right = mid;
        }
        return letters[left];
    }
};
```