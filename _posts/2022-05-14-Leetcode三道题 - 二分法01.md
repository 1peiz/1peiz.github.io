---
layout: post
toc: true
title: "Leetcode三道题 - 二分法01"
categories: Code
tags: [Leetcode]
author:
  - Chris Chen
---


### <a href = "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/">34. Find First and Last Position of Element in Sorted Array</a>
```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) 
    {
        vector<int> res;
        if(nums.size() == 0)
        {
            res.push_back(-1);
            res.push_back(-1);
            return res;
        }
        
        int left = 0;
        int right = nums.size() - 1;
        //找下确界
        //当left == right后，就退出了
        while(left < right)
        {
            int mid = left + (right - left) / 2;
            //nums[mid]  target
            if(target > nums[mid])
                left = mid + 1;
            else 
                right = mid;
        }
        
        if(left == right && nums[left] == target)
            res.push_back(left);
        else
            res.push_back(-1);

        left = 0;
        right = nums.size() - 1;
        //找上确界
        //要注意到，当left，right相邻时会造成死循环，因为left的值没有变化，所以需要让left的坐标往右移一点,加个1
        while(left < right)
        {
            int mid = left + (right - left) / 2 + 1;
            //target  nums[mid]
            if(target < nums[mid])
                right = mid - 1;
            else 
                left = mid;
        }
        if(left == right && nums[left] == target)
            res.push_back(left);
        else
            res.push_back(-1);
        return res;

        
    }
    
};
```


### <a href = "https://leetcode.com/problems/search-insert-position/description/">35. Search Insert Position</a>
```c++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) 
    {
        int left = 0;
        int right = nums.size() - 1;
        while(left < right)
        {
            int mid = left + (right - left) / 2 + 1;
            if(target < nums[mid])
                right = mid - 1;
            else
                left = mid;
        }
        if(nums[left] == target)
            return left;
        if(target > nums[left])
            return left + 1;
        return left == 0 ? left : left - 1;      
    }
};
```

### <a href = "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/">153. Find Minimum in Rotated Sorted Array</a>
```c++
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = 0, right = (int)nums.size() - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            //当旋转点偏左，会导致中间元素值大于最右边界值，所以我们要跑到右边去找
            //而正常情况是中间元素是大于最右边的元素的
            if (nums[mid] > nums[right]) 
                left = mid + 1;
            else 
                right = mid;
        }
        //因为left < right退出的唯一条件就是left == right，所以返回left或者right都可以
        return nums[right];
    }
};
```


### <a href = "https://leetcode.com/problems/first-bad-version/description/">278. First Bad Version</a>
```c++
class Solution {
public:
    int firstBadVersion(int n) 
    {
        int left = 1;
        int right = n;
        while(left < right)
        {
            int mid = left + (right - left)/2;
            if(isBadVersion(mid))
                right = mid;
            else
                left = mid + 1;
        }
        return left;   
    }
};
```