---
layout: post
toc: true
title: "算法复习"
categories: Code
tags: [Leetcode]
author:
  - Chris Chen
---



[toc]



### 1. 蛮力 - 欧几里得算法求最大公约数

```c++

#include <iostream>
using namespace std;
 
int gcd(int m, int n)
{
	int r = 0;
	while(n!=0)
	{
		r=m%n;
		m=n;
		n=r;
	}
	return m;
}
int main()
{
	int m,n;
	cout<<"请输入2个正整数："<<endl;
	cin>>m>>n;
 
	cout<<endl<<"最大公约数为："<<gcd(m,n)<<endl;
	return 0;
}


```

### 3.蛮力 - 选择排序和冒泡排序

```c++
//-------------------选择排序法-------------------
void SelectionSort(int iSort[],int n){
    int  i = 0, j = 0,min=0;
    for (i = 0; i < n - 1; i++){
        min = i;
        for (j = i + 1; j < n ; j++){
            if (iSort[j]<iSort[min]){   //如果要得到降序排列，只要将这里的判断条件改为if (iSort[j]>iSort[min])即可
                min = j;
            }
        }
        swap(iSort[i], iSort[min]);
    }
}
//-------------------冒泡排序法-------------------
void BubbleSort(int iSort[], int n){
    int i = 0, j = 0;
    for (i = 0; i < n - 1; i++){
        for (j = 0; j < n - 1 - i; j++){
            if (iSort[j + 1] < iSort[j]){
                swap(iSort[j + 1], iSort[j]);
            }
        }
    }
}
    
```

### 3.蛮力 - 顺序查找和蛮力匹配

```c++
using namespace std;
//顺序查找 
int main()
{
	int key;//保存待查找数 
	srand((unsigned)time(NULL));//设置随机数种子 
	int num[21];
	for(int i=0;i<20;i++)//赋值 
	{
		num[i]=rand();
	}
	for(int i=0;i<20;i++)
	{
		cout<<num[i]<<" ";
	}
	cout<<endl;
	cout<<"请输入查找数:"<<endl;
	cin>>key; 
	num[21]=key;//提高查找效率,把key放在数组最后面 
	int j=0;
	while(num[j]!=key)
	{
		j++;	
	}
	if(j<21)
	cout<<"目标数在下标为"<<j<<"的位置"<<endl; 
	else
	cout<<"没有找到目标数"<<endl; 
	return 0;
}

//蛮力字符匹配
/**
//该算法实现了蛮力字符串匹配
//输入一个n个字符数组T，代表一段文本
//一个m个字符数组P，代表一个匹配串
//查找成功则返文本中第一个匹配串的下标，否则返回-1
for i⬅0 to m-n do
	j⬅0
	while j<m and P[j]=T[i+j] do
		j⬅j+1
		if j=m return i
return -1
**/
int main()
{
	string text="";//文本字符串 
	string find="";//待查找字符串 
	cout<<"请输入文本字符串:"<<endl;
	cin>>text;
	cin.sync();//清除缓冲区 
	cout<<"请输入待查找字符串:"<<endl;
	cin>>find;
	int n=text.length();//保存文本字符串长度 
	int m=find.length();//保存待查找字符串长度 
	bool flag=false;//判断是否找到了	
	for(int i=0;i<=n-m;i++)//只需要遍历到n-m处 
	{
		int j=0;
		while(j<m&&(find[j]==text[i+j]))//开始进行匹配 
		{
			j++;
			if (j==m)//匹配成功 
			{
				cout<<"匹配字符串从下标"<<i<<"处开始."<<endl;
				flag=true; 
				break; 
			}
		}
	} 
	if(flag==false)
	cout<<"没有找到匹配的字符串."<<endl;
	return 0;
} 
```

### 3.蛮力 - 最近对问题和凸包

```c++
//最近对问题: 求两点最近距离
void BruteForceClosetPoints(Point P[], int n, int &index1, int &index2){//由于要同时返回两个点的下标，因此这里将形参设置为引用变量
    float dmin = FLT_MAX;//常量FLT_MAX 来源于float.h头文件
    int i = 1,j=0;
    float d;
    for (; i < n-1; i++){
        for (j = i + 1; j < n; j++){
            d = (P[i].x - P[j].x)*(P[i].x - P[j].x) + (P[i].y - P[j].y)*(P[i].y - P[j].y);
            if (d < dmin){
                dmin = d;
                index1 = i;
                index2 = j;
            }
        }
    }
}

//凸包
/**
　　用蛮力法解决凸包问题的思路之一是通过找到凸包的边界（两个极点组成的线段）来确定构成凸包的极点。

找到凸包边界的算法是：对于一个n个点集合中的两个点Pi和Pj，当且仅当该集合中的其他点都位于穿过这两点的直线的同一边是，他们的连线是该集合凸包边界的一部分。

在实现上述算法的时候用到的解析几何的基本知识是，当坐标平面上的两个点（X1,Y1）、（X2,Y2）组成的直线方程是：ax+by=c（其中a=Y2-Y1，b=X1-X2，c=X1Y2-X2Y1）

O(n3)
**/
#include <iostream>
#include "最近对问题头文件.h"
using namespace std;
int main(){
    Point P[NUM];
    for (int i = 1; i < NUM; i++){
        cin >> P[i].x >> P[i].y;
     }
    getchar();
    
    BruteForceConvexHull(P, NUM-1);
    cout << "属于凸包集合的点坐标为：" << endl;
    for (int i = 1; i <NUM; i++){
        if (P[i].signal == 1){
        cout << "    (" << P[i].x << "," << P[i].y << ")     "<<endl;
        }
    }
    getchar();
    return 1;
}
int  BruteForceConvexHull(Point P[], int n){
    int i = 1, j = 1, k = 1;
    float a, b, c;
    int sign1 = 0, sign2 = 0;
    for (; i <= n - 1; i++){
        for (j = i + 1; j <= n; j++){
            a = P[j].y - P[i].y;
            b = P[i].x - P[j].x;
            c = P[i].x*P[j].y - P[i].y*P[j].x;
            sign1 = 0;
            sign2 = 0;
            for (k = 1; k <= n; k++){
                if (k == i || k == j){
                    continue;
                }
                if ((a*P[k].x + b*P[k].y - c) <= 0){//此处必须是两个if语句，避免当判断的点在线上时只判断了其中一个并且最好用两个旗帜变量来记录
                    sign1--;
                }
                if ((a*P[k].x + b*P[k].y - c) >= 0)
                {
                    sign2++;
                }

            }
            if ((sign1 == 2 - n) || (sign2 == n - 2)){
                //cout << sign1 << "  " << sign2 << "    点    " << i << "    " << j << "    是极点" << endl;
                P[i].signal = 1;
                P[j].signal = 1;
            }
        }
    }
    return 1;
}


```

### 3. 蛮力 - 穷举查找

```c++
/* 通过硬币数量控制 */
	for (a100 = 0; a100 <= 10; a100++) {
		for (a50 = 0; a50 <= (20 - a100); a50++) {
			for (a10 = 0; a10 <= (20 - a100 - a50); a10++) {
				for (a5 = 0; a5 <= (20 - a100 - a50 - a10); a5++) {
					count3++;
					if ((a100 * 100 + a50 * 50 + a10 * 10 + a5 * 5) == 1000 && (a100 + a50 + a10 + a5) == 20) {
						cout << "1元硬币：" << a100 << "枚， 5角硬币：" << a50 << "枚， 1角硬币：" << a10 << "枚， 5分硬币：" << a5 << "枚！" << endl;
						count++;
					}
				}// a5 end.
			}// a10 end.
		}// a50 end.
	}// a100 end.
```



### 4. 分治法 - 合并排序, 快速排序, 二分查找

```c++
//**********************************************合并排序
// 将arr[l...mid]和arr[mid+1...r]两部分进行归并
template<typename  T>
void __merge(T arr[], int l, int mid, int r){

    //* VS不支持动态长度数组, 即不能使用 T aux[r-l+1]的方式申请aux的空间
    //* 使用VS的同学, 请使用new的方式申请aux空间
    //* 使用new申请空间, 不要忘了在__merge函数的最后, delete掉申请的空间:)
    T aux[r-l+1];
    //T *aux = new T[r-l+1];

    for( int i = l ; i <= r; i ++ )
        aux[i-l] = arr[i];

    // 初始化，i指向左半部分的起始索引位置l；j指向右半部分起始索引位置mid+1
    int i = l, j = mid+1;
    for( int k = l ; k <= r; k ++ ){

        if( i > mid ){  // 如果左半部分元素已经全部处理完毕
            arr[k] = aux[j-l]; j ++;
        }
        else if( j > r ){  // 如果右半部分元素已经全部处理完毕
            arr[k] = aux[i-l]; i ++;
        }
        else if( aux[i-l] < aux[j-l] ) {  // 左半部分所指元素 < 右半部分所指元素
            arr[k] = aux[i-l]; i ++;
        }
        else{  // 左半部分所指元素 >= 右半部分所指元素
            arr[k] = aux[j-l]; j ++;
        }
    }

    //delete[] aux;
}

// 递归使用归并排序,对arr[l...r]的范围进行排序
template<typename T>
void __mergeSort(T arr[], int l, int r){

    if( l >= r )
        return;

    int mid = (l+r)/2;
    __mergeSort(arr, l, mid);
    __mergeSort(arr, mid+1, r);
    __merge(arr, l, mid, r);
}

template<typename T>
void mergeSort(T arr[], int n){

    __mergeSort( arr , 0 , n-1 );
}

//***********************************快速排序
#include <iostream>
#include <algorithm>

using namespace std;


template<typename T>
void insertionSort(T arr[], int n){

    for( int i = 1 ; i < n ; i ++ ) {

        T e = arr[i];
        int j;
        for (j = i; j > 0 && arr[j-1] > e; j--)
            arr[j] = arr[j-1];
        arr[j] = e;
    }

    return;
}

// 对arr[l...r]范围的数组进行插入排序
template<typename T>
void insertionSort(T arr[], int l, int r){

    for( int i = l+1 ; i <= r ; i ++ ) {

        T e = arr[i];
        int j;
        for (j = i; j > l && arr[j-1] > e; j--)
            arr[j] = arr[j-1];
        arr[j] = e;
    }

    return;
}
```



### 4. 分治法 - 大整数乘法

### 5 - 减治法 - 插入排序, DFS ,BFS

```c++
//插入排序
template<typename T>
void insertSort(T arr[], int n)
{
	for(int i = 1; i < n;i++)
	{
		T e = arr[i];
		for(int j = i;j>0;j--)
		{
			if(e < arr[j-1])
			{
				arr[j] = arr[j-1];
			}
			else
			{
				arr[j] = e;
				break;
			}
		}
		
	}
}
//DFS
//function for bfs traversal
void bfs(int s,vector<int>adj[],bool visit[]){
  queue<int>q;//queue in STL
  q.push(s);
  visit[s]=true;
  while(!q.empty()){
    int u=q.front();
    cout<<u<<" ";
    q.pop();
//loop for traverse
    for(int i=0;i<adj[u].size();i++){
      if(!visit[adj[u][i]]){
        q.push(adj[u][i]);
        visit[adj[u][i]]=true;
      }
    }
  }
}
//function for dfs traversal
void dfs(int s,vector<int>adj[],bool visit[]){
  stack<int>stk;//stack in STL
  stk.push(s);
  visit[s]=true;
  while(!stk.empty()){
    int u=stk.top();
    cout<<u<<" ";
    stk.pop();
//loop for traverse
    for(int i=0;i<adj[u].size();i++){
      if(!visit[adj[u][i]]){
        stk.push(adj[u][i]);
        visit[adj[u][i]]=true;
      }
    }
  }
}


```



### 5 -减治法 - 拓扑排序

```c++
```

### 5 - 减治法 - 生成组合对象的方法

```c++
```

### 5 - 减治法 - 减常因子算法

```c++
非递归的二分查找
```

### 6 -  预排序

```c++
```

### 6 -  霍纳法则

```c++


```

### 8 - 动态规划

```c++
/************************warshall floyed***/
//图最短路径
private void floyd() {
    for (int k = 0; k < n; k++) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                a[i][j] = Math.min(a[i][j], a[i][k] + a[k][j]);
            }
        }
    }

    // 打印
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            System.out.println(i + " " + j + ":" + a[i][j]);
        }
    }
}
/***********************lCS***/

class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        vector<vector<int>> dp(text1.size() + 1, vector<int>(text2.size() + 1, 0));
        for (int i = 1; i <= text1.size(); i++) {
            for (int j = 1; j <= text2.size(); j++) {
                if (text1[i - 1] == text2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[text1.size()][text2.size()];
    }
};
/*******************************矩阵链***/
int matrixChain(int[] p){
        int n = p.length - 1; //number of matrices
        int[][] dp = new int[n + 1][n + 1]; //we need dp[1][n]
        int[][] s = new int[n + 1][n + 1];    //for storing of k
        for(int[] row : dp)
            Arrays.fill(row, Integer.MAX_VALUE);

        for(int i = 1; i <= n; i++)
            dp[i][i] = 0;    //dp[i][j] = 0 when i == j

        for(int i = n; i >= 1; i--)
            for(int j = i; j <= n; j++){
                if(i == j){
                    dp[i][j] = 0;
                }else{
                    for(int k = i; k < j; k++){
                        int count = dp[i][k] + dp[k+1][j] + p[i-1]*p[k]*p[j];
                        if(count < dp[i][j]){
                            dp[i][j] = count; //record optimal solution value
                            s[i][j] = k;      //record splitting point k
                        }
                    }
                }
            }
        return dp[1][n];
    }

/***************背包问题**********/


/****************最优二叉查找树***/
```



### 9 - 贪婪 

```c++
/***prim***/

/***kruskal***/

/***dijkstra***/

/***哈夫曼树***/
```



## 10 - 算法能力极限

```c++
/*** p, np, np完全问题 ***/

```

