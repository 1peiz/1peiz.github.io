---
layout: post
toc: true
title: "编写Bitcoin"
categories: 技术
tags: [区块链]
author:
  - chenleyi
---


## Building Blockchain in Go. Part 1: Basic Prototype

16 Aug 2017

> Chinese translations: [by liuchengxu](https://github.com/liuchengxu/blockchain-tutorial/blob/master/content/part-1/basic-prototype.md), [by zhangli1](https://zhangli1.gitbooks.io/dummies-for-blockchain/content/).
> 中文翻译：刘成旭、张莉1。

### Introduction 导言

Blockchain is one of the most revolutionary technologies of the 21st century, which is still maturing and which potential is not fully realized yet. In its essence, blockchain is just a distributed database of records. But what makes it unique is that it’s not a private database, but a public one, i.e. everyone who uses it has a full or partial copy of it. And a new record can be added only with a consent of other keepers of the database. Also, it’s blockchain that made cryptocurrencies and smart contracts possible.
区块链是 21 世纪最具革命性的技术之一，目前仍处于成熟期，其潜力尚未完全发挥出来。从本质上讲，区块链只是一个分布式记录数据库。但它的独特之处在于，它不是一个私人数据库，而是一个公共数据库，也就是说，每个使用它的人都有一个完整或部分副本。只有获得数据库其他保存者的同意，才能添加新的记录。此外，正是区块链让加密货币和智能合约成为可能。

In this series of articles we’ll build a simplified cryptocurrency that’s based on a simple blockchain implementation.
在本系列文章中，我们将构建一种基于简单区块链实现的简化加密货币。

### Block 区块

Let’s start with the “block” part of “blockchain”. In blockchain it’s blocks that store valuable information. For example, bitcoin blocks store transactions, the essence of any cryptocurrency. Besides this, a block contains some technical information, like its version, current timestamp and the hash of the previous block.
让我们从 "区块链 "的 "块 "开始。在区块链中，区块存储有价值的信息。例如，比特币区块存储交易，这是任何加密货币的本质。除此之外，区块还包含一些技术信息，如版本、当前时间戳和上一个区块的哈希值。
In this article we’re not going to implement the block as it’s described in blockchain or Bitcoin specifications, instead we’ll use a simplified version of it, which contains only significant information. Here’s what it looks like:
在本文中，我们不会按照区块链或比特币规范中的描述来实现区块，而是使用简化版的区块，其中只包含重要信息。下面就是它的样子：

```go
type Block struct {
	Timestamp     int64
	Data          []byte
	PrevBlockHash []byte
	Hash          []byte
}
Timestamp` is the current timestamp (when the block is created), `Data` is the actual valuable information containing in the block, `PrevBlockHash` stores the hash of the previous block, and `Hash` is the hash of the block. In Bitcoint specification `Timestamp`, `PrevBlockHash`, and `Hash` are block headers, which form a separate data structure, and transactions (`Data` in our case) is a separate data structure. So we’re mixing them here for simplicity.
`Timestamp` 是当前时间戳（区块创建时）， 是区块中包含的实际有价值信息， 存储上一个区块的哈希值， 是区块的哈希值。在 Bitcoint 规范中， 、 和 是区块头，它们构成一个独立的数据结构，而事务（在我们的例子中为 ）是一个独立的数据结构。因此，为了简单起见，我们将它们混合在一起。 `Data` `PrevBlockHash` `Hash` `Timestamp` `PrevBlockHash` `Hash` `Data
```

So how do we calculate the hashes? The way hashes are calculates is very important feature of blockchain, and it’s this feature that makes blockchain secure. The thing is that calculating a hash is a computationally difficult operation, it takes some time even on fast computers (that’s why people buy powerful GPUs to mine Bitcoin). This is an intentional architectural design, which makes adding new blocks difficult, thus preventing their modification after they’re added. We’ll discuss and implement this mechanism in a future article.
那么，我们如何计算哈希值呢？哈希值的计算方式是区块链非常重要的特征，正是这一特征使得区块链变得安全。问题是，计算哈希值是一项计算难度很大的操作，即使是在速度很快的计算机上也需要一些时间（这就是为什么人们要购买强大的 GPU 来挖掘比特币）。这是一种有意的架构设计，它使得添加新区块变得困难，从而防止区块添加后被修改。我们将在以后的文章中讨论并实现这一机制。

For now, we’ll just take block fields, concatenate them, and calculate a SHA-256 hash on the concatenated combination. Let’s do this in `SetHash` method:
现在，我们只需获取块字段，将它们连接起来，然后计算连接组合的 SHA-256 哈希值。让我们在 `SetHash` 方法中完成这项工作：

```go
func (b *Block) SetHash() {
	timestamp := []byte(strconv.FormatInt(b.Timestamp, 10))
	headers := bytes.Join([][]byte{b.PrevBlockHash, b.Data, timestamp}, []byte{})
	hash := sha256.Sum256(headers)

	b.Hash = hash[:]
}
```

Next, following a Golang convention, we’ll implement a function that’ll simplify the creation of a block:
接下来，按照 Golang 的惯例，我们将实现一个函数来简化程序块的创建：

```go
func NewBlock(data string, prevBlockHash []byte) *Block {
	block := &Block{time.Now().Unix(), []byte(data), prevBlockHash, []byte{}}
	block.SetHash()
	return block
}
```

And that’s it for the block!
这个街区就这样了！

### Blockchain 区块链

Now let’s implement a blockchain. In its essence blockchain is just a database with certain structure: it’s an ordered, back-linked list. Which means that blocks are stored in the insertion order and that each block is linked to the previous one. This structure allows to quickly get the latest block in a chain and to (efficiently) get a block by its hash.
现在，让我们来实现区块链。从本质上讲，区块链只是一个具有特定结构的数据库：它是一个有序、反向链接的列表。这意味着区块按照插入顺序存储，每个区块都与前一个区块链接。这种结构可以快速获取链中的最新区块，并通过区块的哈希值（有效）获取区块。

In Golang this structure can be implemented by using an array and a map: the array would keep ordered hashes (arrays are ordered in Go), and the map would keep `hash → block` pairs (maps are unordered). But for our blockchain prototype we’ll just use an array, because we don’t need to get blocks by their hash for now.
在 Golang 中，这种结构可以通过使用数组和映射来实现：数组将保存有序的哈希值（在 Go 中数组是有序的），映射将保存 `hash → block` 对（映射是无序的）。但对于我们的区块链原型，我们将只使用数组，因为我们暂时不需要通过哈希值来获取区块。

```go
type Blockchain struct {
	blocks []*Block
}
```

This is our first blockchain! I’ve never thought it would be so easy 😉
这是我们的第一个区块链！我从未想过它会如此简单 😉

Now let’s make it possible to add blocks to it:
现在，让我们为它添加区块吧：

```go
func (bc *Blockchain) AddBlock(data string) {
	prevBlock := bc.blocks[len(bc.blocks)-1]
	newBlock := NewBlock(data, prevBlock.Hash)
	bc.blocks = append(bc.blocks, newBlock)
}
```

That’s it! Or not?..
就是这样！还是没有？

To add a new block we need an existing block, but there’re not blocks in our blockchain! So, in any blockchain, there must be at least one block, and such block, the first in the chain, is called **genesis block**. Let’s implement a method that creates such a block:
要添加一个新区块，我们需要一个现有的区块，但我们的区块链中没有区块！因此，在任何区块链中，都必须至少有一个区块，这样的区块，也就是链中的第一个区块，被称为创世区块。让我们来实现一个创建创世区块的方法：

```go
func NewGenesisBlock() *Block {
	return NewBlock("Genesis Block", []byte{})
}
```

Now, we can implement a function that creates a blockchain with the genesis block:
现在，我们可以实现一个函数，用创世区块创建一个区块链：

```go
func NewBlockchain() *Blockchain {
	return &Blockchain{[]*Block{NewGenesisBlock()}}
}
```

Let’s check that the blockchain works correctly:
让我们检查一下区块链是否正常运行：

```go
func main() {
	bc := NewBlockchain()

	bc.AddBlock("Send 1 BTC to Ivan")
	bc.AddBlock("Send 2 more BTC to Ivan")

	for _, block := range bc.blocks {
		fmt.Printf("Prev. hash: %x\n", block.PrevBlockHash)
		fmt.Printf("Data: %s\n", block.Data)
		fmt.Printf("Hash: %x\n", block.Hash)
		fmt.Println()
	}
}
```

Output: 输出：

```
Prev. hash:
Data: Genesis Block
Hash: aff955a50dc6cd2abfe81b8849eab15f99ed1dc333d38487024223b5fe0f1168

Prev. hash: aff955a50dc6cd2abfe81b8849eab15f99ed1dc333d38487024223b5fe0f1168
Data: Send 1 BTC to Ivan
Hash: d75ce22a840abb9b4e8fc3b60767c4ba3f46a0432d3ea15b71aef9fde6a314e1

Prev. hash: d75ce22a840abb9b4e8fc3b60767c4ba3f46a0432d3ea15b71aef9fde6a314e1
Data: Send 2 more BTC to Ivan
Hash: 561237522bb7fcfbccbc6fe0e98bbbde7427ffe01c6fb223f7562288ca2295d1
```

That’s it! 就是这样！

### Conclusion 结论

We built a very simple blockchain prototype: it’s just an array of blocks, with each block having a connection to the previous one. The actual blockchain is much more complex though. In our blockchain adding new blocks is easy and fast, but in real blockchain adding new blocks requires some work: one has to perform some heavy computations before getting a permission to add block (this mechanism is called Proof-of-Work). Also, blockchain is a distributed database that has no single decision maker. Thus, a new block must be confirmed and approved by other participants of the network (this mechanism is called consensus). And there’re no transactions in our blockchain yet!
我们构建了一个非常简单的区块链原型：它只是一个区块数组，每个区块都与前一个区块有关联。但实际的区块链要复杂得多。在我们的区块链中，添加新区块既简单又快速，但在真正的区块链中，添加新区块需要做一些工作：在获得添加区块的许可之前，必须执行一些繁重的计算（这种机制称为工作证明）。此外，区块链是一个分布式数据库，没有单一的决策者。因此，新区块必须得到网络其他参与者的确认和批准（这种机制称为共识）。我们的区块链中还没有交易！

In future articles we’ll cover each of these features.
在今后的文章中，我们将逐一介绍这些功能。

------

Links: 链接

1. Full source codes: https://github.com/Jeiwan/blockchain_go/tree/part_1
   完整源代码： https://github.com/Jeiwan/blockchain_go/tree/part_1
2. Block hashing algorithm: https://en.bitcoin.it/wiki/Block_hashing_algorithm
   块散列算法： https://en.bitcoin.it/wiki/Block_hashing_algorithm

## Building Blockchain in Go. Part 2: Proof-of-Work

22 Aug 2017

> Chinese translations: [by liuchengxu](https://github.com/liuchengxu/blockchain-tutorial/blob/master/content/part-2/proof-of-work.md), [by zhangli1](https://zhangli1.gitbooks.io/dummies-for-blockchain/content/).
> 中文翻译：刘成旭、张莉1。

### Introduction 导言

In [the previous article](https://jeiwan.net/posts/building-blockchain-in-go-part-1/) we built a very simple data structure, which is the essence of blockchain database. And we made it possible to add blocks to it with the chain-like relation between them: each block is linked to the previous one. Alas, our blockchain implementation has one significant flaw: adding blocks to the chain is easy and cheap. One of the keystones of blockchain and Bitcoin is that adding new blocks is a hard work. Today we’re going to fix this flaw.
在上一篇文章中，我们构建了一个非常简单的数据结构，它是区块链数据库的精髓。我们还使区块之间的链式关系成为可能：每个区块都与前一个区块相关联。可惜，我们的区块链实现有一个重大缺陷：向链上添加区块既简单又便宜。区块链和比特币的基石之一就是添加新区块是一项艰苦的工作。今天，我们要弥补这个缺陷。

### Proof-of-Work 工作证明

A key idea of blockchain is that one has to perform some hard work to put data in it. It is this hard work that makes blockchain secure and consistent. Also, a reward is paid for this hard work (this is how people get coins for mining).
区块链的一个关键理念是，人们必须进行一些艰苦的工作才能将数据存入区块链。正是这种艰苦的工作使得区块链具有安全性和一致性。同时，这种艰苦的工作也会得到回报（这就是人们挖矿获得金币的方式）。

This mechanism is very similar to the one from real life: one has to work hard to get a reward and to sustain their life. In blockchain, some participants (miners) of the network work to sustain the network, to add new blocks to it, and get a reward for their work. As a result of their work, a block is incorporated into the blockchain in a secure way, which maintains the stability of the whole blockchain database. It’s worth noting that, the one who finished the work has to prove this.
这种机制与现实生活中的机制非常相似：人们必须努力工作，才能获得回报，维持生活。在区块链中，网络的一些参与者（矿工）努力维持网络，为网络添加新的区块，并从他们的工作中获得回报。由于他们的工作，一个区块以安全的方式被纳入区块链，从而保持了整个区块链数据库的稳定性。值得注意的是，完成工作的人必须证明这一点。

This whole “do hard work and prove” mechanism is called proof-of-work. It’s hard because it requires a lot of computational power: even high performance computers cannot do it quickly. Moreover, the difficulty of this work increases from time to time to keep new blocks rate at about 6 blocks per hour. In Bitcoin, the goal of such work is to find a hash for a block, that meets some requirements. And it’s this hash that serves as a proof. Thus, finding a proof is the actual work.
这种 "做艰苦的工作并证明 "的机制被称为工作量证明（proof-of-work）。说它难，是因为它需要大量的计算能力：即使是高性能计算机也无法快速完成。此外，这项工作的难度会不时增加，以保持每小时大约 6 个新区块的速度。在比特币中，这项工作的目标是为一个区块找到符合某些要求的哈希值。这个哈希值就是证明。因此，找到证明才是真正的工作。

One last thing to note. Proof-of-Work algorithms must meet a requirement: doing the work is hard, but verifying the proof is easy. A proof is usually handed to someone else, so for them, it shouldn’t take much time to verify it.
最后一点需要注意。工作证明算法必须满足一个要求：做工作很难，但验证证明很容易。证明通常是交给别人的，因此对他们来说，验证它不应该花费太多时间。

### Hashing 散列

In this paragraph, we’ll discuss hashing. If you’re familiar with the concept, you can skip this part.
在本段中，我们将讨论散列。如果你熟悉这个概念，可以跳过这一部分。

Hashing is a process of obtaining a hash for specified data. A hash is a unique representation of the data it was calculated on. A hash function is a function that takes data of arbitrary size and produces a fixed size hash. Here are some key features of hashing:
散列是为指定数据获取散列值的过程。散列是计算数据的唯一表示。散列函数是一种可以获取任意大小数据并生成固定大小散列的函数。下面是散列的一些主要特征：

1. Original data cannot be restored from a hash. Thus, hashing is not encryption.
   原始数据无法从散列值中还原。因此，散列不是加密。
2. Certain data can have only one hash and the hash is unique.
   某些数据只能有一个哈希值，而且该哈希值是唯一的。
3. Changing even one byte in the input data will result in a completely different hash.
   哪怕是改变输入数据中的一个字节，都会产生完全不同的哈希值。

![Hashing example](https://jeiwan.net/images/hashing-example.png)

Hashing functions are widely used to check the consistency of data. Some software providers publish checksums in addition to a software package. After downloading a file you can feed it to a hashing function and compare produced hash with the one provided by the software developer.
散列函数被广泛用于检查数据的一致性。一些软件提供商会在软件包中发布校验和。下载文件后，您可以将其输入散列函数，然后将产生的散列与软件开发商提供的散列进行比较。

In blockchain, hashing is used to guarantee the consistency of a block. The input data for a hashing algorithm contains the hash of the previous block, thus making it impossible (or, at least, quite difficult) to modify a block in the chain: one has to recalculate its hash and hashes of all the blocks after it.
在区块链中，哈希算法用于保证区块的一致性。哈希算法的输入数据包含前一个区块的哈希值，因此不可能（或至少相当困难）修改链中的一个区块：必须重新计算其哈希值和其后所有区块的哈希值。

### Hashcash 哈希现金

Bitcoin uses [Hashcash](https://en.wikipedia.org/wiki/Hashcash), a Proof-of-Work algorithm that was initially developed to prevent email spam. It can be split into the following steps:
比特币使用哈希现金，这是一种工作证明算法，最初是为了防止垃圾邮件而开发的。它可以分为以下几个步骤：

1. Take some publicly known data (in case of email, it’s receiver’s email address; in case of Bitcoin, it’s block headers).
   获取一些公开的数据（如果是电子邮件，则是接收者的电子邮件地址；如果是比特币，则是区块头信息）。

2. Add a counter to it. The counter starts at 0.
   添加一个计数器。计数器从 0 开始。

3. Get a hash of the `data + counter` combination.
   获取 `data + counter` 组合的哈希值。

4. Check that the hash meets certain requirements.

   
   检查哈希值是否符合某些要求。

   1. If it does, you’re done.
      如果是这样，你就完了。
   2. If it doesn’t, increase the counter and repeat the steps 3 and 4.
      如果没有，则增加计数器并重复步骤 3 和 4。

Thus, this is a brute force algorithm: you change the counter, calculate a new hash, check it, increment the counter, calculate a hash, etc. That’s why it’s computationally expensive.
因此，这是一种蛮力算法：改变计数器，计算新的哈希值，检查，递增计数器，计算哈希值，等等。这就是为什么它的计算成本很高。

Now let’s look closer at the requirements a hash has to meet. In the original Hashcash implementation, the requirement sounds like “first 20 bits of a hash must be zeros”. In Bitcoin, the requirement is adjusted from time to time, because, by design, a block must be generated every 10 minutes, despite computation power increasing with time and more and more miners joining the network.
现在，让我们仔细看看哈希值必须满足的要求。在最初的 Hashcash 实现中，这个要求听起来像是 "哈希值的前 20 位必须为零"。在比特币中，这一要求会不时调整，因为根据设计，尽管计算能力会随着时间的推移而增加，而且越来越多的矿工加入网络，但每隔 10 分钟就必须生成一个区块。

To demonstrate this algorithm, I took the data from the previous example (“I like donuts”) and found a hash that starts with 3 zero-bytes:
为了演示这种算法，我从上一个例子（"我喜欢甜甜圈"）中获取数据，并找到一个以 3 个 0 字节开头的哈希值：

![Hashcash example](https://jeiwan.net/images/hashcash-example.png)

`ca07ca` is the hexadecimal value of the counter, which is 13240266 in the decimal system.
`ca07ca` 是计数器的十六进制值，十进制为 13240266。

### Implementation 实施情况

Ok, we’re done with the theory, let’s write code! First, let’s define the difficulty of mining:
好了，理论讲完了，我们来写代码吧！首先，我们来定义采矿的难度：

```go
const targetBits = 24
```

In Bitcoin, “target bits” is the block header storing the difficulty at which the block was mined. We won’t implement a target adjusting algorithm, for now, so we can just define the difficulty as a global constant.
在比特币中，"目标比特 "是指存储区块开采难度的区块头。我们暂时不会实施目标调整算法，因此我们可以将难度定义为一个全局常量。

24 is an arbitrary number, our goal is to have a target that takes less than 256 bits in memory. And we want the difference to be significant enough, but not too big, because the bigger the difference the more difficult it’s to find a proper hash.
24 是一个任意数字，我们的目标是在内存中占用少于 256 位的目标值。我们希望差值足够大，但又不能太大，因为差值越大，找到合适的哈希值就越困难。

```go
type ProofOfWork struct {
	block  *Block
	target *big.Int
}

func NewProofOfWork(b *Block) *ProofOfWork {
	target := big.NewInt(1)
	target.Lsh(target, uint(256-targetBits))

	pow := &ProofOfWork{b, target}

	return pow
}
```

Here create `ProofOfWork` structure that holds a pointer to a block and a pointer to a target. “target” is another name for the requirement described in the previous paragraph. We use a [big](https://golang.org/pkg/math/big/) integer because of the way we’ll compare a hash to the target: we’ll convert a hash to a big integer and check if it’s less than the target.
在此创建 `ProofOfWork` 结构，其中包含一个指向代码块的指针和一个指向目标的指针。"目标 "是上一段描述的需求的另一个名称。我们使用大整数是因为我们将哈希值与目标值进行比较的方式：我们将哈希值转换为大整数，然后检查它是否小于目标值。

In the `NewProofOfWork` function, we initialize a `big.Int` with the value of 1 and shift it left by `256 - targetBits` bits. `256` is the length of a SHA-256 hash in bits, and it’s SHA-256 hashing algorithm that we’re going to use. The hexadecimal representation of `target` is:
在 `NewProofOfWork` 函数中，我们将 `big.Int` 初始化为 1，然后将其左移 `256 - targetBits` 位。 `256` 是 SHA-256 哈希值的长度（位），我们要使用的就是 SHA-256 哈希算法。 `target` 的十六进制表示为

```
0x10000000000000000000000000000000000000000000000000000000000
```

And it occupies 29 bytes in memory. And here’s its visual comparison with the hashes from the previous examples:
它占用内存 29 个字节。下面是它与前面例子中的哈希值的直观对比：

```
0fac49161af82ed938add1d8725835cc123a1a87b1b196488360e58d4bfb51e3
0000010000000000000000000000000000000000000000000000000000000000
0000008b0f41ec78bab747864db66bcb9fb89920ee75f43fdaaeb5544f7f76ca
```

The first hash (calculated on “I like donuts”) is bigger than the target, thus it’s not a valid proof of work. The second hash (calculated on “I like donutsca07ca”) is smaller than the target, thus it’s a valid proof.
第一个哈希值（根据 "我喜欢甜甜圈 "计算）大于目标值，因此不是有效的工作证明。第二个哈希值（根据 "我喜欢甜甜圈 "计算）小于目标值，因此是一个有效的证明。

You can think of a target as the upper boundary of a range: if a number (a hash) is lower than the boundary, it’s valid, and vice versa. Lowering the boundary will result in fewer valid numbers, and thus, more difficult work required to find a valid one.
你可以把目标视为一个范围的上边界：如果一个数字（哈希值）低于边界，它就是有效的，反之亦然。边界越低，有效数字越少，因此找到有效数字的难度也就越大。

Now, we need the data to hash. Let’s prepare it:
现在，我们需要散列数据。让我们来准备一下：

```go
func (pow *ProofOfWork) prepareData(nonce int) []byte {
	data := bytes.Join(
		[][]byte{
			pow.block.PrevBlockHash,
			pow.block.Data,
			IntToHex(pow.block.Timestamp),
			IntToHex(int64(targetBits)),
			IntToHex(int64(nonce)),
		},
		[]byte{},
	)

	return data
}
```

This piece is straightforward: we just merge block fields with the target and nonce. `nonce` here is the counter from the Hashcash description above, this is a cryptographic term.
`nonce` 是上面 Hashcash 描述中的计数器，这是一个加密术语。

Ok, all preparations are done, let’s implement the core of the PoW algorithm:
好了，所有准备工作都完成了，让我们来实现 PoW 算法的核心：

```go
func (pow *ProofOfWork) Run() (int, []byte) {
	var hashInt big.Int
	var hash [32]byte
	nonce := 0

	fmt.Printf("Mining the block containing \"%s\"\n", pow.block.Data)
	for nonce < maxNonce {
		data := pow.prepareData(nonce)
		hash = sha256.Sum256(data)
		fmt.Printf("\r%x", hash)
		hashInt.SetBytes(hash[:])

		if hashInt.Cmp(pow.target) == -1 {
			break
		} else {
			nonce++
		}
	}
	fmt.Print("\n\n")

	return nonce, hash[:]
}
```

First, we initialize variables: `hashInt` is the integer representation of `hash`; `nonce` is the counter. Next, we run an “infinite” loop: it’s limited by `maxNonce`, which equals to `math.MaxInt64`; this is done to avoid a possible overflow of `nonce`. Although the difficulty of our PoW implementation is too low for the counter to overflow, it’s still better to have this check, just in case.
首先，我们对变量进行初始化： `hashInt` 是 `hash` 的整数表示； `nonce` 是计数器。接下来，我们运行一个 "无限 "循环：它受 `maxNonce` 的限制，等于 `math.MaxInt64` ；这样做是为了避免 `nonce` 可能出现的溢出。虽然我们的 PoW 实现难度很低，计数器不会溢出，但最好还是进行这种检查，以防万一。

In the loop we:
在循环中，我们

1. Prepare data. 准备数据。
2. Hash it with SHA-256.
   使用 SHA-256 对其进行散列。
3. Convert the hash to a big integer.
   将哈希值转换为大整数。
4. Compare the integer with the target.
   将整数与目标值进行比较。

As easy as it was explained earlier. Now we can remove the `SetHash` method of `Block` and modify the `NewBlock` function:
就像前面解释的那样简单。现在我们可以删除 `Block` 中的 `SetHash` 方法，并修改 `NewBlock` 函数：

```go
func NewBlock(data string, prevBlockHash []byte) *Block {
	block := &Block{time.Now().Unix(), []byte(data), prevBlockHash, []byte{}, 0}
	pow := NewProofOfWork(block)
	nonce, hash := pow.Run()

	block.Hash = hash[:]
	block.Nonce = nonce

	return block
}
```

Here you can see that `nonce` is saved as a `Block` property. This is necessary because `nonce` is required to verify a proof. The `Block` structure now looks so:
在这里，您可以看到 `nonce` 被保存为 `Block` 属性。这是必要的，因为需要 `nonce` 来验证证明。 `Block` 结构现在看起来是这样的：

```go
type Block struct {
	Timestamp     int64
	Data          []byte
	PrevBlockHash []byte
	Hash          []byte
	Nonce         int
}
```

Alright! Let’s run the program to see if everything works fine:
好吧！让我们运行程序，看看是否一切正常：

```
Mining the block containing "Genesis Block"
00000041662c5fc2883535dc19ba8a33ac993b535da9899e593ff98e1eda56a1

Mining the block containing "Send 1 BTC to Ivan"
00000077a856e697c69833d9effb6bdad54c730a98d674f73c0b30020cc82804

Mining the block containing "Send 2 more BTC to Ivan"
000000b33185e927c9a989cc7d5aaaed739c56dad9fd9361dea558b9bfaf5fbe

Prev. hash:
Data: Genesis Block
Hash: 00000041662c5fc2883535dc19ba8a33ac993b535da9899e593ff98e1eda56a1

Prev. hash: 00000041662c5fc2883535dc19ba8a33ac993b535da9899e593ff98e1eda56a1
Data: Send 1 BTC to Ivan
Hash: 00000077a856e697c69833d9effb6bdad54c730a98d674f73c0b30020cc82804

Prev. hash: 00000077a856e697c69833d9effb6bdad54c730a98d674f73c0b30020cc82804
Data: Send 2 more BTC to Ivan
Hash: 000000b33185e927c9a989cc7d5aaaed739c56dad9fd9361dea558b9bfaf5fbe
```

Yay! You can see that every hash now starts with three zero bytes, and it takes some time to get these hashes.
是啊！你可以看到，现在每个哈希值都以三个 0 字节开始，而获取这些哈希值需要一些时间。

There’s one more thing left to do: let’s make it possible to validate proof of works.
还有一件事要做：让验证作品证明成为可能。

```go
func (pow *ProofOfWork) Validate() bool {
	var hashInt big.Int

	data := pow.prepareData(pow.block.Nonce)
	hash := sha256.Sum256(data)
	hashInt.SetBytes(hash[:])

	isValid := hashInt.Cmp(pow.target) == -1

	return isValid
}
```

And this is where we need the saved nonce.
这就是我们需要已保存的 nonce 的地方。

Let’s check one more time that everything’s ok:
让我们再检查一遍是否一切正常：

```go
func main() {
	...

	for _, block := range bc.blocks {
		...
		pow := NewProofOfWork(block)
		fmt.Printf("PoW: %s\n", strconv.FormatBool(pow.Validate()))
		fmt.Println()
	}
}
```

Output: 输出：

```
...

Prev. hash:
Data: Genesis Block
Hash: 00000093253acb814afb942e652a84a8f245069a67b5eaa709df8ac612075038
PoW: true

Prev. hash: 00000093253acb814afb942e652a84a8f245069a67b5eaa709df8ac612075038
Data: Send 1 BTC to Ivan
Hash: 0000003eeb3743ee42020e4a15262fd110a72823d804ce8e49643b5fd9d1062b
PoW: true

Prev. hash: 0000003eeb3743ee42020e4a15262fd110a72823d804ce8e49643b5fd9d1062b
Data: Send 2 more BTC to Ivan
Hash: 000000e42afddf57a3daa11b43b2e0923f23e894f96d1f24bfd9b8d2d494c57a
PoW: true
```

### Conclusion 结论

Our blockchain is a step closer to its actual architecture: adding blocks now requires hard work, thus mining is possible. But it still lacks some crucial features: the blockchain database is not persistent, there are no wallets, addresses, transactions, and there’s no consensus mechanism. All these things we’ll implement in future articles, and for now, happy mining!
我们的区块链向其实际架构又迈进了一步：现在添加区块需要艰苦的工作，因此挖矿是可能的。但它仍然缺乏一些关键功能：区块链数据库不是持久的，没有钱包、地址、交易，也没有共识机制。所有这些我们都将在未来的文章中实现，现在，祝您挖矿愉快！

------

Links: 链接

1. [Full source codes 完整源代码](https://github.com/Jeiwan/blockchain_go/tree/part_2)
2. [Blockchain hashing algorithm
   区块链散列算法](https://en.bitcoin.it/wiki/Block_hashing_algorithm)
3. [Proof of work 工作证明](https://en.bitcoin.it/wiki/Proof_of_work)
4. [Hashcash 哈希现金](https://en.bitcoin.it/wiki/Hashcash)



## Building Blockchain in Go. Part 3: Persistence and CLI

29 Aug 2017

> Chinese translations: [by liuchengxu](https://github.com/liuchengxu/blockchain-tutorial/blob/master/content/part-3/persistence-and-cli.md), [by zhangli1](https://zhangli1.gitbooks.io/dummies-for-blockchain/content/).
> 中文翻译：刘成旭、张莉1。

### Introduction 导言

[So](https://jeiwan.net/posts/building-blockchain-in-go-part-1/) [far](https://jeiwan.net/posts/building-blockchain-in-go-part-2/), we’ve built a blockchain with a proof-of-work system, which makes mining possible. Our implementation is getting closer to a fully functional blockchain, but it still lacks some important features. Today will start storing a blockchain in a database, and after that we’ll make a simple command-line interface to perform operations with the blockchain. In its essence, blockchain is a distributed database. We’re going to omit the “distributed” part for now and focus on the “database” part.
到目前为止，我们已经建立了一个带有工作量证明系统的区块链，这使得挖矿成为可能。我们的实现越来越接近一个功能齐全的区块链，但它仍然缺乏一些重要功能。今天我们将开始在数据库中存储区块链，之后我们将制作一个简单的命令行界面来对区块链进行操作。从本质上讲，区块链是一个分布式数据库。我们暂时省略 "分布式 "这一部分，重点讨论 "数据库 "这一部分。

### Database Choice 数据库选择

Currently, there’s no database in our implementation; instead, we create blocks every time we run the program and store them in memory. We cannot reuse a blockchain, we cannot share it with others, thus we need to store it on the disk.
目前，我们的实现中没有数据库；相反，我们每次运行程序时都会创建区块，并将其存储在内存中。我们不能重复使用区块链，也不能与他人共享，因此需要将其存储在磁盘上。

Which database do we need? Actually, any of them. In [the original Bitcoin paper](https://bitcoin.org/bitcoin.pdf), nothing is said about using a certain database, so it’s up to a developer what DB to use. [Bitcoin Core](https://github.com/bitcoin/bitcoin), which was initially published by Satoshi Nakamoto and which is currently a reference implementation of Bitcoin, uses [LevelDB](https://github.com/google/leveldb) (although it was introduced to the client only in 2012). And we’ll use…
我们需要哪个数据库？其实，任何一个都可以。在最初的比特币论文中，并没有提到要使用某种数据库，所以使用什么数据库取决于开发者。最初由中本聪发布的 Bitcoin Core 目前是比特币的参考实现，它使用 LevelDB（尽管它在 2012 年才被引入客户端）。我们将使用...

### BoltDB

Because: 因为

1. It’s simple and minimalistic.
   它简单而简约。
2. It’s implemented in Go.
   它是用 Go 语言实现的。
3. It doesn’t require to run a server.
   它不需要运行服务器。
4. It allows to build the data structure we want.
   它允许建立我们想要的数据结构。

From the BoltDB’s [README on Github](https://github.com/boltdb/bolt):
摘自 Github 上 BoltDB 的 README：

> Bolt is a pure Go key/value store inspired by Howard Chu’s LMDB project. The goal of the project is to provide a simple, fast, and reliable database for projects that don’t require a full database server such as Postgres or MySQL.
> Bolt 是一个纯 Go 的键/值存储库，其灵感来自 Howard Chu 的 LMDB 项目。该项目的目标是为不需要 Postgres 或 MySQL 等完整数据库服务器的项目提供一个简单、快速、可靠的数据库。

> Since Bolt is meant to be used as such a low-level piece of functionality, simplicity is key. The API will be small and only focus on getting values and setting values. That’s it.
> 由于 Bolt 只是一个低级功能，因此简单是关键。应用程序接口（API）将非常小，只关注获取值和设置值。就是这样。

Sounds perfect for our needs! Let’s spend a minute reviewing it.
听起来非常适合我们的需要！让我们花一分钟来回顾一下。

BoltDB is a key/value storage, which means there’re no tables like in SQL RDBMS (MySQL, PostgreSQL, etc.), no rows, no columns. Instead, data is stored as key-value pairs (like in Golang maps). Key-value pairs are stored in buckets, which are intended to group similar pairs (this is similar to tables in RDBMS). Thus, in order to get a value, you need to know a bucket and a key.
BoltDB 是键/值存储，这意味着没有像 SQL RDBMS（MySQL、PostgreSQL 等）那样的表格，没有行，也没有列。相反，数据是以键值对的形式存储的（就像在 Golang 地图中一样）。键值对存储在桶中，目的是将类似的键值对分组（这与 RDBMS 中的表格类似）。因此，要获取一个值，你需要知道一个桶和一个键。

One important thing about BoltDB is that there are no data types: keys and values are byte arrays. Since we’ll store Go structs (`Block`, in particular) in it, we’ll need to serialize them, i.e. implement a mechanism of converting a Go struct into a byte array and restoring it back from a byte array. We’ll use [encoding/gob](https://golang.org/pkg/encoding/gob/) for this, but `JSON`, `XML`, `Protocol Buffers`, etc. can be used as well. We’re using `encoding/gob` because it’s simple and is a part of the standard Go library.
BoltDB 的一个重要特点是没有数据类型：键和值都是字节数组。由于我们将在其中存储 Go 结构体（尤其是 `Block` ），因此需要对其进行序列化，即实现一种机制，将 Go 结构体转换为字节数组，并从字节数组还原回来。为此，我们将使用编码/gob，但也可以使用 `JSON` , `XML` , `Protocol Buffers` 等。我们使用 `encoding/gob` 是因为它很简单，而且是标准 Go 库的一部分。

### Database Structure 数据库结构

Before starting implementing persistence logic, we first need to decide how we’ll store data in the DB. And for this, we’ll refer to the way Bitcoin Core does that.
在开始实施持久化逻辑之前，我们首先需要决定如何在数据库中存储数据。为此，我们将参考 Bitcoin Core 的做法。

In simple words, Bitcoin Core uses two “buckets” to store data:
简单地说，Bitcoin Core 使用两个 "桶 "来存储数据：

1. `blocks` stores metadata describing all the blocks in a chain.
   `blocks` 存储描述链中所有区块的元数据。
2. `chainstate` stores the state of a chain, which is all currently unspent transaction outputs and some metadata.
   `chainstate` 存储链的状态，即当前所有未使用的事务输出和一些元数据。

Also, blocks are stored as separate files on the disk. This is done for a performance purpose: reading a single block won’t require loading all (or some) of them into memory. We won’t implement this.
此外，数据块以单独文件的形式存储在磁盘上。这样做的目的是为了提高性能：读取单个数据块时不需要将所有（或部分）数据块加载到内存中。我们不会实现这一点。

In `blocks`, the `key -> value` pairs are:
在 `blocks` 中， `key -> value` 对：

1. `'b' + 32-byte block hash -> block index record`
2. `'f' + 4-byte file number -> file information record`
3. `'l' -> 4-byte file number: the last block file number used`
4. `'R' -> 1-byte boolean: whether we're in the process of reindexing`
5. `'F' + 1-byte flag name length + flag name string -> 1 byte boolean: various flags that can be on or off`
6. `'t' + 32-byte transaction hash -> transaction index record`

In `chainstate`, the `key -> value` pairs are:
在 `chainstate` 中， `key -> value` 对：

1. `'c' + 32-byte transaction hash -> unspent transaction output record for that transaction`
2. `'B' -> 32-byte block hash: the block hash up to which the database represents the unspent transaction outputs`

*(Detailed explanation can be found [here](https://en.bitcoin.it/wiki/Bitcoin_Core_0.11_(ch_2):_Data_Storage))
(详细解释见此处）*

Since we don’t have transactions yet, we’re going to have only `blocks` bucket. Also, as said above, we will store the whole DB as a single file, without storing blocks in separate files. So we won’t need anything related to file numbers. So these are `key -> value` pairs we’ll use:
由于我们还没有事务，所以只有 `blocks` bucket。此外，如上所述，我们会将整个数据库存储为一个文件，而不会将数据块存储在单独的文件中。因此，我们不需要任何与文件编号相关的东西。因此，我们将使用 `key -> value` 对：

1. `32-byte block-hash -> Block structure (serialized)`
2. `'l' -> the hash of the last block in a chain`

That’s all we need to know to start implementing the persistence mechanism.
这就是我们开始实施持久性机制所需要知道的一切。

### Serialization 序列化

As said before, in BoltDB values can be only of `[]byte` type, and we want to store `Block` structs in the DB. We’ll use [encoding/gob](https://golang.org/pkg/encoding/gob/) to serialize the structs.
如前所述，在 BoltDB 中，值只能是 `[]byte` 类型，而我们希望在数据库中存储 `Block` 结构体。我们将使用编码/gob 来序列化结构体。

Let’s implement `Serialize` method of `Block` (errors processing is omitted for brevity):
让我们实现 `Serialize` 方法 `Block` （为简洁起见，错误处理省略）：

```go
func (b *Block) Serialize() []byte {
	var result bytes.Buffer
	encoder := gob.NewEncoder(&result)

	err := encoder.Encode(b)

	return result.Bytes()
}
```

The piece is straightforward: at first, we declare a buffer that will store serialized data; then we initialize a `gob` encoder and encode the block; the result is returned as a byte array.
该程序简单明了：首先，我们声明一个将存储序列化数据的缓冲区；然后，我们初始化一个 `gob` 编码器并对数据块进行编码；结果以字节数组的形式返回。

Next, we need a deserializing function that will receive a byte array as input and return a `Block`. This won’t be a method but an independent function:
接下来，我们需要一个反序列化函数，接收字节数组作为输入，并返回 `Block` 。这不是一个方法，而是一个独立函数：

```go
func DeserializeBlock(d []byte) *Block {
	var block Block

	decoder := gob.NewDecoder(bytes.NewReader(d))
	err := decoder.Decode(&block)

	return &block
}
```

And that’s it for the serialization!
连载到此为止！

### Persistence 坚持不懈

Let’s start with the `NewBlockchain` function. Currently, it creates a new instance of `Blockchain` and adds the genesis block to it. What we want it to do is to:
让我们从 `NewBlockchain` 函数开始。目前，它创建了一个 `Blockchain` 的新实例，并添加了 genesis 块。我们想让它做的是

1. Open a DB file.
   打开 DB 文件。

2. Check if there’s a blockchain stored in it.
   检查其中是否存储有区块链。

3. If there’s a blockchain:

   
   如果有区块链

   1. Create a new `Blockchain` instance.
      创建一个新的 `Blockchain` 实例。
   2. Set the tip of the `Blockchain` instance to the last block hash stored in the DB.
      将 `Blockchain` 实例的提示设置为数据库中存储的最后一个块哈希值。

4. If there’s no existing blockchain:

   
   如果没有现成的区块链：

   1. Create the genesis block.
      创建创世区块。
   2. Store in the DB.
      存储在数据库中。
   3. Save the genesis block’s hash as the last block hash.
      将创世区块的哈希值保存为最后一个区块的哈希值。
   4. Create a new `Blockchain` instance with its tip pointing at the genesis block.
      创建一个新的 `Blockchain` 实例，其尖端指向创世块。

In code, it looks like this:
代码是这样的

```go
func NewBlockchain() *Blockchain {
	var tip []byte
	db, err := bolt.Open(dbFile, 0600, nil)

	err = db.Update(func(tx *bolt.Tx) error {
		b := tx.Bucket([]byte(blocksBucket))

		if b == nil {
			genesis := NewGenesisBlock()
			b, err := tx.CreateBucket([]byte(blocksBucket))
			err = b.Put(genesis.Hash, genesis.Serialize())
			err = b.Put([]byte("l"), genesis.Hash)
			tip = genesis.Hash
		} else {
			tip = b.Get([]byte("l"))
		}

		return nil
	})

	bc := Blockchain{tip, db}

	return &bc
}
```

Let’s review this piece by piece.
让我们逐一回顾一下。

```go
db, err := bolt.Open(dbFile, 0600, nil)
```

This is a standard way of opening a BoltDB file. Notice that it won’t return an error if there’s no such file.
这是打开 BoltDB 文件的标准方法。请注意，如果没有此类文件，它不会返回错误。

```go
err = db.Update(func(tx *bolt.Tx) error {
...
})
```

In BoltDB, operations with a database are run within a transaction. And there are two types of transactions: read-only and read-write. Here, we open a read-write transaction (`db.Update(...)`), because we expect to put the genesis block in the DB.
在 BoltDB 中，对数据库的操作是在事务中进行的。事务有两种类型：只读事务和读写事务。在这里，我们打开一个读写事务 ( `db.Update(...)` )，因为我们希望把创世块放到数据库中。

```go
b := tx.Bucket([]byte(blocksBucket))

if b == nil {
	genesis := NewGenesisBlock()
	b, err := tx.CreateBucket([]byte(blocksBucket))
	err = b.Put(genesis.Hash, genesis.Serialize())
	err = b.Put([]byte("l"), genesis.Hash)
	tip = genesis.Hash
} else {
	tip = b.Get([]byte("l"))
}
```

This is the core of the function. Here, we obtain the bucket storing our blocks: if it exists, we read the `l` key from it; if it doesn’t exist, we generate the genesis block, create the bucket, save the block into it, and update the `l` key storing the last block hash of the chain.
这是功能的核心。在这里，我们获取存储区块的 "桶"：如果 "桶 "存在，我们就从中读取 `l` 密钥；如果 "桶 "不存在，我们就生成创世区块，创建 "桶"，将区块保存到 "桶 "中，并更新存储链上最后一个区块哈希值的 `l` 密钥。

Also, notice the new way of creating a `Blockchain`:
此外，请注意创建 `Blockchain` 的新方法：

```go
bc := Blockchain{tip, db}
```

We don’t store all the blocks in it anymore, instead only the tip of the chain is stored. Also, we store a DB connection, because we want to open it once and keep it open while the program is running. Thus, the `Blockchain` structure now looks like this:
我们不再在其中存储所有区块，而是只存储链的顶端。此外，我们还存储了一个数据库连接，因为我们希望只打开一次，并在程序运行时保持打开状态。因此， `Blockchain` 结构现在看起来像这样：

```go
type Blockchain struct {
	tip []byte
	db  *bolt.DB
}
```

Next thing we want to update is the `AddBlock` method: adding blocks to a chain now is not as easy as adding an element to an array. From now on we’ll store blocks in the DB:
接下来我们要更新的是 `AddBlock` 方法：现在向链中添加区块并不像向数组中添加元素那么简单。从现在起，我们将在数据库中存储区块：

```go
func (bc *Blockchain) AddBlock(data string) {
	var lastHash []byte

	err := bc.db.View(func(tx *bolt.Tx) error {
		b := tx.Bucket([]byte(blocksBucket))
		lastHash = b.Get([]byte("l"))

		return nil
	})

	newBlock := NewBlock(data, lastHash)

	err = bc.db.Update(func(tx *bolt.Tx) error {
		b := tx.Bucket([]byte(blocksBucket))
		err := b.Put(newBlock.Hash, newBlock.Serialize())
		err = b.Put([]byte("l"), newBlock.Hash)
		bc.tip = newBlock.Hash

		return nil
	})
}
```

Let’s review this piece by piece:
让我们逐一回顾一下：

```go
err := bc.db.View(func(tx *bolt.Tx) error {
	b := tx.Bucket([]byte(blocksBucket))
	lastHash = b.Get([]byte("l"))

	return nil
})
```

This is the other (read-only) type of BoltDB transactions. Here we get the last block hash from the DB to use it to mine a new block hash.
这是 BoltDB 事务的另一种（只读）类型。在这里，我们从数据库中获取最后一个区块的哈希值，用于挖掘新的区块哈希值。

```go
newBlock := NewBlock(data, lastHash)
b := tx.Bucket([]byte(blocksBucket))
err := b.Put(newBlock.Hash, newBlock.Serialize())
err = b.Put([]byte("l"), newBlock.Hash)
bc.tip = newBlock.Hash
```

After mining a new block, we save its serialized representation into the DB and update the `l` key, which now stores the new block’s hash.
挖出一个新区块后，我们会将其序列化表示保存到数据库中，并更新 `l` 密钥，现在该密钥存储了新区块的哈希值。

Done! It wasn’t hard, was it?
完成了不难吧？

### Inspecting Blockchain 检查区块链

All new blocks are now saved in a database, so we can reopen a blockchain and add a new block to it. But after implementing this, we lost a nice feature: we cannot print out blockchain blocks anymore because we don’t store blocks in an array any longer. Let’s fix this flaw!
现在，所有新区块都保存在数据库中，因此我们可以重新打开区块链并向其中添加新区块。但是，实现这一点后，我们失去了一个很好的功能：我们无法再打印出区块链区块，因为我们不再将区块存储在数组中。让我们来修复这个缺陷！

BoltDB allows to iterate over all the keys in a bucket, but the keys are stored in byte-sorted order, and we want blocks to be printed in the order they take in a blockchain. Also, because we don’t want to load all the blocks into memory (our blockchain DB could be huge!.. or let’s just pretend it could), we’ll read them one by one. For this purpose, we’ll need a blockchain iterator:
BoltDB 允许遍历一个桶中的所有密钥，但密钥是按字节排序存储的，而我们希望按区块链中的顺序打印区块。此外，由于我们不想将所有区块加载到内存中（我们的区块链数据库可能非常庞大！或者让我们假装它非常庞大），因此我们将逐个读取。为此，我们需要一个区块链迭代器：

```go
type BlockchainIterator struct {
	currentHash []byte
	db          *bolt.DB
}
```

An iterator will be created each time we want to iterate over blocks in a blockchain and it’ll store the block hash of the current iteration and a connection to a DB. Because of the latter, an iterator is logically attached to a blockchain (it’s a `Blockchain` instance that stores a DB connection) and, thus, is created in a `Blockchain` method:
每次我们要迭代区块链中的区块时，都会创建一个迭代器，它将存储当前迭代的区块哈希值和与数据库的连接。由于后者，迭代器在逻辑上与区块链相连（它是一个存储数据库连接的 `Blockchain` 实例），因此在 `Blockchain` 方法中创建：

```go
func (bc *Blockchain) Iterator() *BlockchainIterator {
	bci := &BlockchainIterator{bc.tip, bc.db}

	return bci
}
```

Notice that an iterator initially points at the tip of a blockchain, thus blocks will be obtained from top to bottom, from newest to oldest. In fact, **choosing a tip means “voting” for a blockchain**. A blockchain can have multiple branches, and it’s the longest of them that’s considered main. After getting a tip (it can be any block in the blockchain) we can reconstruct the whole blockchain and find its length and the work required to build it. This fact also means that a tip is a kind of an identifier of a blockchain.
请注意，迭代器最初指向的是区块链的顶端，因此区块将从上到下、从最新到最旧地获取。事实上，选择顶端意味着为区块链 "投票"。一个区块链可以有多个分支，其中最长的分支才被视为主链。得到一个提示（可以是区块链中的任何区块）后，我们就可以重构整个区块链，找出它的长度和构建它所需的工作量。这一事实也意味着提示是区块链的一种标识符。

`BlockchainIterator` will do only one thing: it’ll return the next block from a blockchain.
`BlockchainIterator` 只会做一件事：从区块链中返回下一个区块。

```go
func (i *BlockchainIterator) Next() *Block {
	var block *Block

	err := i.db.View(func(tx *bolt.Tx) error {
		b := tx.Bucket([]byte(blocksBucket))
		encodedBlock := b.Get(i.currentHash)
		block = DeserializeBlock(encodedBlock)

		return nil
	})

	i.currentHash = block.PrevBlockHash

	return block
}
```

That’s it for the DB part!
DB 部分到此为止！

### CLI

Until now our implementation hasn’t provided any interface to interact with the program: we’ve simply executed `NewBlockchain`, `bc.AddBlock` in the `main` function. Time to improve this! We want to have these commands:
到目前为止，我们的实现还没有提供任何与程序交互的接口：我们只是在 `main` 函数中执行了 `NewBlockchain` , `bc.AddBlock` 。是时候改进了！我们需要这些命令：

```
blockchain_go addblock "Pay 0.031337 for a coffee"
blockchain_go printchain
```

All command-line related operations will be processed by the `CLI` struct:
所有与命令行相关的操作都将由 `CLI` 结构处理：

```go
type CLI struct {
	bc *Blockchain
}
```

Its “entrypoint” is the `Run` function:
其 "入口点 "是 `Run` 函数：

```go
func (cli *CLI) Run() {
	cli.validateArgs()

	addBlockCmd := flag.NewFlagSet("addblock", flag.ExitOnError)
	printChainCmd := flag.NewFlagSet("printchain", flag.ExitOnError)

	addBlockData := addBlockCmd.String("data", "", "Block data")

	switch os.Args[1] {
	case "addblock":
		err := addBlockCmd.Parse(os.Args[2:])
	case "printchain":
		err := printChainCmd.Parse(os.Args[2:])
	default:
		cli.printUsage()
		os.Exit(1)
	}

	if addBlockCmd.Parsed() {
		if *addBlockData == "" {
			addBlockCmd.Usage()
			os.Exit(1)
		}
		cli.addBlock(*addBlockData)
	}

	if printChainCmd.Parsed() {
		cli.printChain()
	}
}
```

We’re using the standard [flag](https://golang.org/pkg/flag/) package to parse command-line arguments.
我们使用标准标志包来解析命令行参数。

```go
addBlockCmd := flag.NewFlagSet("addblock", flag.ExitOnError)
printChainCmd := flag.NewFlagSet("printchain", flag.ExitOnError)
addBlockData := addBlockCmd.String("data", "", "Block data")
```

First, we create two subcommands, `addblock` and `printchain`, then we add `-data` flag to the former. `printchain` won’t have any flags.
首先，我们创建两个子命令 `addblock` 和 `printchain` ，然后在前者中添加 `-data` 标志。 `printchain` 不会有任何标志。

```go
switch os.Args[1] {
case "addblock":
	err := addBlockCmd.Parse(os.Args[2:])
case "printchain":
	err := printChainCmd.Parse(os.Args[2:])
default:
	cli.printUsage()
	os.Exit(1)
}
```

Next we check the command provided by user and parse related `flag` subcommand.
接下来，我们检查用户提供的命令，并解析相关的 `flag` 子命令。

```go
if addBlockCmd.Parsed() {
	if *addBlockData == "" {
		addBlockCmd.Usage()
		os.Exit(1)
	}
	cli.addBlock(*addBlockData)
}

if printChainCmd.Parsed() {
	cli.printChain()
}
```

Next we check which of the subcommands were parsed and run related functions.
接下来，我们检查哪些子命令已被解析，并运行相关函数。

```go
func (cli *CLI) addBlock(data string) {
	cli.bc.AddBlock(data)
	fmt.Println("Success!")
}

func (cli *CLI) printChain() {
	bci := cli.bc.Iterator()

	for {
		block := bci.Next()

		fmt.Printf("Prev. hash: %x\n", block.PrevBlockHash)
		fmt.Printf("Data: %s\n", block.Data)
		fmt.Printf("Hash: %x\n", block.Hash)
		pow := NewProofOfWork(block)
		fmt.Printf("PoW: %s\n", strconv.FormatBool(pow.Validate()))
		fmt.Println()

		if len(block.PrevBlockHash) == 0 {
			break
		}
	}
}
```

This piece is very similar to the one we had before. The only difference is that we’re now using a `BlockchainIterator` to iterate over blocks in a blockchain.
这一块与我们之前的一块非常相似。唯一不同的是，我们现在使用 `BlockchainIterator` 来遍历区块链中的区块。

Also let’s not forget to modify the `main` function accordingly:
此外，不要忘记对 `main` 函数进行相应的修改：

```go
func main() {
	bc := NewBlockchain()
	defer bc.db.Close()

	cli := CLI{bc}
	cli.Run()
}
```

Note that a new `Blockchain` is created no matter what command-line arguments are provided.
请注意，无论提供什么命令行参数，都会创建一个新的 `Blockchain` 。

And that’s it! Let’s check that everything works as expected:
就是这样！让我们检查一下是否一切正常：

```shell
$ blockchain_go printchain
No existing blockchain found. Creating a new one...
Mining the block containing "Genesis Block"
000000edc4a82659cebf087adee1ea353bd57fcd59927662cd5ff1c4f618109b

Prev. hash:
Data: Genesis Block
Hash: 000000edc4a82659cebf087adee1ea353bd57fcd59927662cd5ff1c4f618109b
PoW: true

$ blockchain_go addblock -data "Send 1 BTC to Ivan"
Mining the block containing "Send 1 BTC to Ivan"
000000d7b0c76e1001cdc1fc866b95a481d23f3027d86901eaeb77ae6d002b13

Success!

$ blockchain_go addblock -data "Pay 0.31337 BTC for a coffee"
Mining the block containing "Pay 0.31337 BTC for a coffee"
000000aa0748da7367dec6b9de5027f4fae0963df89ff39d8f20fd7299307148

Success!

$ blockchain_go printchain
Prev. hash: 000000d7b0c76e1001cdc1fc866b95a481d23f3027d86901eaeb77ae6d002b13
Data: Pay 0.31337 BTC for a coffee
Hash: 000000aa0748da7367dec6b9de5027f4fae0963df89ff39d8f20fd7299307148
PoW: true

Prev. hash: 000000edc4a82659cebf087adee1ea353bd57fcd59927662cd5ff1c4f618109b
Data: Send 1 BTC to Ivan
Hash: 000000d7b0c76e1001cdc1fc866b95a481d23f3027d86901eaeb77ae6d002b13
PoW: true

Prev. hash:
Data: Genesis Block
Hash: 000000edc4a82659cebf087adee1ea353bd57fcd59927662cd5ff1c4f618109b
PoW: true
```

*(sound of a beer can opening)
(啤酒罐打开的声音）*

### Conclusion 结论

Next time we’ll implement addresses, wallets, and (probably) transactions. So stay tuned!
下一次，我们将实现地址、钱包和（可能）交易。敬请期待！

### Links 链接

1. [Full source codes 完整源代码](https://github.com/Jeiwan/blockchain_go/tree/part_3)
2. [Bitcoin Core Data Storage
   比特币核心数据存储](https://en.bitcoin.it/wiki/Bitcoin_Core_0.11_(ch_2):_Data_Storage)
3. [boltdb 螺栓库](https://github.com/boltdb/bolt)
4. [encoding/gob 编码/gob](https://golang.org/pkg/encoding/gob/)
5. [flag 国旗](https://golang.org/pkg/flag/)



## Building Blockchain in Go. Part 4: Transactions 1

04 Sep 2017

> Chinese translations: [by liuchengxu](https://github.com/liuchengxu/blockchain-tutorial/blob/master/content/part-4/transactions-1.md), [by zhangli1](https://zhangli1.gitbooks.io/dummies-for-blockchain/content/)
> 中文翻译：刘成旭、张莉1

### Introduction 导言

Transactions are the heart of Bitcoin and the only purpose of blockchain is to store transactions in a secure and reliable way, so no one could modify them after they are created. Today we’re starting implementing transactions. But because this is quite a big topic, I’ll split it into two parts: in this part, we’ll implement the general mechanism of transactions and in the second part we’ll work through details.
交易是比特币的核心，而区块链的唯一目的就是以安全可靠的方式存储交易，这样就不会有人在交易创建后对其进行修改。今天，我们开始实现交易。但由于这是一个相当大的话题，我将把它分成两部分：在这一部分，我们将实现交易的一般机制，而在第二部分，我们将研究细节。

Also, since code changes are massive, it makes no sense describing all of them here. You can see all the changes [here](https://github.com/Jeiwan/blockchain_go/compare/part_3...part_4#files_bucket).
此外，由于代码改动非常大，在此无法一一描述。您可以在这里查看所有更改。

### There is no spoon 没有勺子

If you’ve ever developed a web application, in order to implement payments you would likely to create these tables in a DB: `accounts` and `transactions`. An account would store information about a user, including their personal information and balance, and a transaction would store information about money transferring from one account to another. In Bitcoin, payments are realized in completely different way. There are:
如果您曾经开发过一个网络应用程序，为了实现支付功能，您很可能要在数据库中创建这些表： `accounts` 和 `transactions` 。账户存储用户的信息，包括个人信息和余额，交易则存储从一个账户向另一个账户转账的信息。在比特币中，支付是以完全不同的方式实现的。有

1. No accounts. 没有账户。
2. No balances. 没有余额。
3. No addresses. 没有地址。
4. No coins. 没有硬币
5. No senders and receivers.
   没有发送器和接收器。

Since blockchain is a public and open database, we don’t want to store sensitive information about wallet owners. Coins are not collected in accounts. Transactions do not transfer money from one address to another. There’s no field or attribute that holds account balance. There are only transactions. But what’s inside a transaction?
由于区块链是一个公开、开放的数据库，我们不想存储钱包所有者的敏感信息。硬币不会被收集到账户中。交易不会将钱从一个地址转移到另一个地址。没有记录账户余额的字段或属性。只有交易。但是，交易里面有什么呢？

### Bitcoin Transaction 比特币交易

A transaction is a combination of inputs and outputs:
交易是输入和输出的组合：

```go
type Transaction struct {
	ID   []byte
	Vin  []TXInput
	Vout []TXOutput
}
```

Inputs of a new transaction reference outputs of a previous transaction (there’s an exception though, which we’ll discuss later). Outputs are where coins are actually stored. The following diagram demonstrates the interconnection of transactions:
新交易的输入会参考之前交易的输出（但有一个例外，我们稍后会讨论）。输出是实际存储硬币的地方。下图展示了交易之间的相互连接：

![Transactions](https://jeiwan.net/images/transactions-diagram.png)

Notice that: 请注意

1. There are outputs that are not linked to inputs.
   有些输出与输入没有关联。
2. In one transaction, inputs can reference outputs from multiple transactions.
   在一个事务中，输入可以引用多个事务的输出。
3. An input must reference an output.
   输入必须引用输出。

Throughout this article, we’ll use words like “money”, “coins”, “spend”, “send”, “account”, etc. But there are no such concepts in Bitcoin. Transactions just lock values with a script, which can be unlocked only by the one who locked them.
在本文中，我们将使用 "钱"、"币"、"花"、"发送"、"账户 "等词汇。但比特币中没有这些概念。交易只是用脚本锁定价值，只有锁定者才能解锁。

### Transaction Outputs 交易输出

Let’s start with outputs first:
先说产出：

```go
type TXOutput struct {
	Value        int
	ScriptPubKey string
}
```

Actually, it’s outputs that store “coins” (notice the `Value` field above). And storing means locking them with a puzzle, which is stored in the `ScriptPubKey`. Internally, Bitcoin uses a scripting language called *Script*, that is used to define outputs locking and unlocking logic. The language is quite primitive (this is made intentionally, to avoid possible hacks and misuses), but we won’t discuss it in details. You can find a detailed explanation of it [here](https://en.bitcoin.it/wiki/Script).
实际上，存储 "硬币 "的是输出（注意上面的 `Value` 字段）。存储的意思是用一个谜题锁定它们，谜题存储在 `ScriptPubKey` 中。比特币内部使用一种叫做脚本的脚本语言，用来定义输出锁定和解锁逻辑。这种语言非常原始（这是有意为之，以避免可能的黑客攻击和滥用），但我们不会详细讨论它。你可以在这里找到详细的解释。

> In Bitcoin, the *value* field stores the number of *satoshis*, not the number of BTC. A *satoshi* is a hundred millionth of a bitcoin (0.00000001 BTC), thus this is the smallest unit of currency in Bitcoin (like a cent).
> 在比特币中，价值字段存储的是 satoshis 的数量，而不是 BTC 的数量。一个 satoshi 是一个比特币的一亿分之一（0.00000001 BTC），因此它是比特币中最小的货币单位（就像美分一样）。

Since we don’t have addresses implemented, we’ll avoid the whole scripting related logic for now. `ScriptPubKey` will store an arbitrary string (user defined wallet address).
`ScriptPubKey` 将存储任意字符串（用户定义的钱包地址）。

> By the way, having such scripting language means that Bitcoin can be used as a smart-contract platform as well.
> 顺便说一句，拥有这样的脚本语言意味着比特币也可以用作智能合约平台。

One important thing about outputs is that they are **indivisible**, which means that you cannot reference a part of its value. When an output is referenced in a new transaction, it’s spent as a whole. And if its value is greater than required, a change is generated and sent back to the sender. This is similar to a real world situation when you pay, say, a $5 banknote for something that costs $1 and get a change of $4.
关于输出，有一点很重要，那就是它们是不可分割的，这意味着你不能引用其价值的一部分。当在新事务中引用一个输出时，它将作为一个整体使用。如果它的值大于所需值，就会产生变化并发送回发送方。这与现实世界中的情况类似，比如你用一张 5 美元的纸币支付了 1 美元的东西，并得到了 4 美元的零钱。

### Transaction Inputs 交易输入

And here’s the input:
这就是输入：

```go
type TXInput struct {
	Txid      []byte
	Vout      int
	ScriptSig string
}
```

As mentioned earlier, an input references a previous output: `Txid` stores the ID of such transaction, and `Vout` stores an index of an output in the transaction. `ScriptSig` is a script which provides data to be used in an output’s `ScriptPubKey`. If the data is correct, the output can be unlocked, and its value can be used to generate new outputs; if it’s not correct, the output cannot be referenced in the input. This is the mechanism that guarantees that users cannot spend coins belonging to other people.
如前所述，输入会引用之前的输出： `Txid` 存储该事务的 ID， `Vout` 存储该事务中输出的索引。 `ScriptSig` 是一个脚本，提供用于输出的数据 `ScriptPubKey` 。如果数据正确，输出就可以解锁，其值可用于生成新的输出；如果数据不正确，输出就不能在输入中引用。这就是保证用户不能花费属于其他人的硬币的机制。

Again, since we don’t have addresses implemented yet, `ScriptSig` will store just an arbitrary user defined wallet address. We’ll implement public keys and signatures checking in the next article.
同样，由于我们还没有实现地址， `ScriptSig` 只会存储用户定义的任意钱包地址。我们将在下一篇文章中实现公钥和签名检查。

Let’s sum it up. Outputs are where “coins” are stored. Each output comes with an unlocking script, which determines the logic of unlocking the output. Every new transaction must have at least one input and output. An input references an output from a previous transaction and provides data (the `ScriptSig` field) that is used in the output’s unlocking script to unlock it and use its value to create new outputs.
让我们来总结一下。输出端是存储 "硬币 "的地方。每个输出都有一个解锁脚本，它决定了解锁输出的逻辑。每笔新交易必须至少有一个输入和输出。输入会引用上一笔交易的输出，并提供数据（ `ScriptSig` 字段），输出的解锁脚本会使用这些数据来解锁输出，并使用其值创建新的输出。

But what came first: inputs or outputs?
但是，投入和产出哪个在先？

### The egg 鸡蛋

In Bitcoin, it’s the egg that came before the chicken. The inputs-referencing-outputs logic is the classical “chicken or the egg” situation: inputs produce outputs and outputs make inputs possible. And in Bitcoin, outputs come before inputs.
在比特币中，先有蛋后有鸡。输入-参考-输出逻辑是经典的 "先有鸡还是先有蛋"：输入产生输出，输出使输入成为可能。而在比特币中，产出先于投入。

When a miner starts mining a block, it adds a **coinbase transaction** to it. A coinbase transaction is a special type of transactions, which doesn’t require previously existing outputs. It creates outputs (i.e., “coins”) out of nowhere. The egg without a chicken. This is the reward miners get for mining new blocks.
当矿工开始挖掘一个区块时，就会为该区块添加 Coinbase 交易。Coinbase 交易是一种特殊类型的交易，它不需要先前存在的输出。它可以凭空产生输出（即 "币"）。没有鸡的蛋。这是矿工挖掘新区块获得的奖励。

As you know, there’s the genesis block in the beginning of a blockchain. It’s this block that generates the very first output in the blockchain. And no previous outputs are required since there are no previous transactions and no such outputs.
众所周知，区块链的开头有一个创世区块。正是这个区块产生了区块链中的第一个输出。由于没有之前的交易和输出，因此不需要之前的输出。

Let’s create a coinbase transaction:
让我们创建一个 Coinbase 交易：

```go
func NewCoinbaseTX(to, data string) *Transaction {
	if data == "" {
		data = fmt.Sprintf("Reward to '%s'", to)
	}

	txin := TXInput{[]byte{}, -1, data}
	txout := TXOutput{subsidy, to}
	tx := Transaction{nil, []TXInput{txin}, []TXOutput{txout}}
	tx.SetID()

	return &tx
}
```

A coinbase transaction has only one input. In our implementation its `Txid` is empty and `Vout` equals to -1. Also, a coinbase transaction doesn’t store a script in `ScriptSig`. Instead, arbitrary data is stored there.
Coinbase 交易只有一个输入。在我们的实现中， `Txid` 为空， `Vout` 等于-1。此外，Coinbase 交易不会在 `ScriptSig` 中存储脚本。而是存储任意数据。

> In Bitcoin, the very first coinbase transaction contains the following message: “The Times 03/Jan/2009 Chancellor on brink of second bailout for banks”. [You can see it yourself](https://blockchain.info/tx/4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b?show_adv=true).
> 在比特币中，第一笔Coinbase交易包含以下信息："泰晤士报 2009年1月3日 英国首相濒临第二次救助银行"你可以自己看看

```
subsidy` is the amount of reward. In Bitcoin, this number is not stored anywhere and calculated based only on the total number of blocks: the number of blocks is divided by `210000`. Mining the genesis block produced 50 BTC, and every `210000` blocks the reward is halved. In our implementation, we’ll store the reward as a constant (at least for now 😉 ).
`subsidy` 是奖励金额。在比特币中，这个数字不存储在任何地方，只根据区块总数计算：区块数除以 。挖掘创世区块可以获得 50 BTC，每挖掘 个区块，奖励就会减半。在我们的实现中，我们会将奖励存储为一个常数（至少现在是这样😉）。 `210000` `210000
```

### Storing Transactions in Blockchain 在区块链中存储交易

From now on, every block must store at least one transaction and it’s no more possible to mine blocks without transactions. This means that we should remove the `Data` field of `Block` and store transactions instead:
从现在起，每个区块都必须至少存储一笔交易，没有交易的区块是无法挖矿的。这意味着我们应该删除 `Block` 的 `Data` 字段，转而存储交易：

```go
type Block struct {
	Timestamp     int64
	Transactions  []*Transaction
	PrevBlockHash []byte
	Hash          []byte
	Nonce         int
}
NewBlock` and `NewGenesisBlock` also must be changed accordingly:
`NewBlock` 和 也必须相应更改： `NewGenesisBlock
func NewBlock(transactions []*Transaction, prevBlockHash []byte) *Block {
	block := &Block{time.Now().Unix(), transactions, prevBlockHash, []byte{}, 0}
	...
}

func NewGenesisBlock(coinbase *Transaction) *Block {
	return NewBlock([]*Transaction{coinbase}, []byte{})
}
```

Next thing to change is the creation of a new blockchain:
下一个变化是创建新的区块链：

```go
func CreateBlockchain(address string) *Blockchain {
	...
	err = db.Update(func(tx *bolt.Tx) error {
		cbtx := NewCoinbaseTX(address, genesisCoinbaseData)
		genesis := NewGenesisBlock(cbtx)

		b, err := tx.CreateBucket([]byte(blocksBucket))
		err = b.Put(genesis.Hash, genesis.Serialize())
		...
	})
	...
}
```

Now, the function takes an address which will receive the reward for mining the genesis block.
现在，该函数将获取一个地址，该地址将获得开采创世区块的奖励。

### Proof-of-Work 工作证明

The Proof-of-Work algorithm must consider transactions stored in a block, to guarantee the consistency and reliability of blockchain as a storage of transaction. So now we must modify the `ProofOfWork.prepareData` method:
工作证明算法必须考虑存储在区块中的交易，以保证区块链作为交易存储的一致性和可靠性。因此，现在我们必须修改 `ProofOfWork.prepareData` 方法：

```go
func (pow *ProofOfWork) prepareData(nonce int) []byte {
	data := bytes.Join(
		[][]byte{
			pow.block.PrevBlockHash,
			pow.block.HashTransactions(), // This line was changed
			IntToHex(pow.block.Timestamp),
			IntToHex(int64(targetBits)),
			IntToHex(int64(nonce)),
		},
		[]byte{},
	)

	return data
}
```

Instead of `pow.block.Data` we now use `pow.block.HashTransactions()` which is:
我们现在不使用 `pow.block.Data` ，而是使用 `pow.block.HashTransactions()` ：

```go
func (b *Block) HashTransactions() []byte {
	var txHashes [][]byte
	var txHash [32]byte

	for _, tx := range b.Transactions {
		txHashes = append(txHashes, tx.ID)
	}
	txHash = sha256.Sum256(bytes.Join(txHashes, []byte{}))

	return txHash[:]
}
```

Again, we’re using hashing as a mechanism of providing unique representation of data. We want all transactions in a block to be uniquely identified by a single hash. To achieve this, we get hashes of each transaction, concatenate them, and get a hash of the concatenated combination.
同样，我们使用哈希算法作为一种提供唯一数据表示的机制。我们希望一个区块中的所有事务都能通过一个哈希值唯一标识。为了实现这一目标，我们需要获取每笔交易的哈希值，将它们连接起来，然后获取连接组合的哈希值。

> Bitcoin uses a more elaborate technique: it represents all transactions containing in a block as a [Merkle tree](https://en.wikipedia.org/wiki/Merkle_tree) and uses the root hash of the tree in the Proof-of-Work system. This approach allows to quickly check if a block contains certain transaction, having only just the root hash and without downloading all the transactions.
> 比特币使用了一种更复杂的技术：它将一个区块中包含的所有交易表示为一棵梅克尔树，并在工作证明系统中使用该树的根切集值。这种方法只需根哈希值，无需下载所有交易，就能快速检查一个区块是否包含某些交易。

Let’s check that everything is correct so far:
让我们检查一下目前的一切是否正确：

```shell
$ blockchain_go createblockchain -address Ivan
00000093450837f8b52b78c25f8163bb6137caf43ff4d9a01d1b731fa8ddcc8a

Done!
```

Good! We received out first mining reward. But how do we check the balance?
很好！我们收到了第一笔采矿奖励。但我们如何查看余额呢？

### Unspent Transaction Outputs 未用交易输出

We need to find all unspent transaction outputs (UTXO). *Unspent* means that these outputs weren’t referenced in any inputs. On the diagram above, these are:
我们需要找到所有未使用的交易输出（UTXO）。未使用意味着这些输出没有在任何输入中被引用。在上图中，这些输出是

1. tx0, output 1; tx0，输出 1；
2. tx1, output 0; tx1，输出 0；
3. tx3, output 0; tx3，输出 0；
4. tx4, output 0. tx4，输出 0。

Of course, when we check balance, we don’t need all of them, but only those that can be unlocked by the key we own (currently we don’t have keys implemented and will use user defined addresses instead). First, let’s define locking-unlocking methods on inputs and outputs:
当然，当我们检查余额时，我们并不需要所有的余额，而只需要那些可以通过我们拥有的密钥解锁的余额（目前我们还没有实现密钥，将使用用户定义的地址来代替）。首先，让我们定义输入和输出的锁定-解锁方法：

```go
func (in *TXInput) CanUnlockOutputWith(unlockingData string) bool {
	return in.ScriptSig == unlockingData
}

func (out *TXOutput) CanBeUnlockedWith(unlockingData string) bool {
	return out.ScriptPubKey == unlockingData
}
```

Here we just compare the script fields with `unlockingData`. These pieces will be improved in a future article, after we implement addresses based on private keys.
在这里，我们只是将脚本字段与 `unlockingData` 进行比较。在实现基于私钥的地址后，我们将在今后的文章中对这些部分进行改进。

The next step - finding transactions containing unspent outputs - is quite difficult:
下一步--查找包含未用产出的交易--相当困难：

```go
func (bc *Blockchain) FindUnspentTransactions(address string) []Transaction {
  var unspentTXs []Transaction
  spentTXOs := make(map[string][]int)
  bci := bc.Iterator()

  for {
    block := bci.Next()

    for _, tx := range block.Transactions {
      txID := hex.EncodeToString(tx.ID)

    Outputs:
      for outIdx, out := range tx.Vout {
        // Was the output spent?
        if spentTXOs[txID] != nil {
          for _, spentOut := range spentTXOs[txID] {
            if spentOut == outIdx {
              continue Outputs
            }
          }
        }

        if out.CanBeUnlockedWith(address) {
          unspentTXs = append(unspentTXs, *tx)
        }
      }

      if tx.IsCoinbase() == false {
        for _, in := range tx.Vin {
          if in.CanUnlockOutputWith(address) {
            inTxID := hex.EncodeToString(in.Txid)
            spentTXOs[inTxID] = append(spentTXOs[inTxID], in.Vout)
          }
        }
      }
    }

    if len(block.PrevBlockHash) == 0 {
      break
    }
  }

  return unspentTXs
}
```

Since transactions are stored in blocks, we have to check every block in a blockchain. We start with outputs:
由于交易存储在区块中，我们必须检查区块链中的每个区块。我们从输出开始：

```go
if out.CanBeUnlockedWith(address) {
	unspentTXs = append(unspentTXs, tx)
}
```

If an output was locked by the same address we’re searching unspent transaction outputs for, then this is the output we want. But before taking it, we need to check if an output was already referenced in an input:
如果某个输出被锁定的地址与我们搜索未用事务输出的地址相同，那么这就是我们想要的输出。但在获取之前，我们需要检查某个输出是否已在输入中被引用：

```go
if spentTXOs[txID] != nil {
	for _, spentOut := range spentTXOs[txID] {
		if spentOut == outIdx {
			continue Outputs
		}
	}
}
```

We skip those that were referenced in inputs (their values were moved to other outputs, thus we cannot count them). After checking outputs we gather all inputs that could unlock outputs locked with the provided address (this doesn’t apply to coinbase transactions, since they don’t unlock outputs):
我们跳过那些在输入中被引用的输入（它们的值被转移到其他输出中，因此我们无法计算它们）。检查输出后，我们会收集所有可以解锁与所提供地址锁定的输出的输入（这不适用于 coinbase 交易，因为它们不会解锁输出）：

```go
if tx.IsCoinbase() == false {
    for _, in := range tx.Vin {
        if in.CanUnlockOutputWith(address) {
            inTxID := hex.EncodeToString(in.Txid)
            spentTXOs[inTxID] = append(spentTXOs[inTxID], in.Vout)
        }
    }
}
```

The function returns a list of transactions containing unspent outputs. To calculate balance we need one more function that takes the transactions and returns only outputs:
该函数返回一个包含未用输出的交易列表。为了计算余额，我们还需要一个函数，该函数接收交易并只返回产出：

```go
func (bc *Blockchain) FindUTXO(address string) []TXOutput {
       var UTXOs []TXOutput
       unspentTransactions := bc.FindUnspentTransactions(address)

       for _, tx := range unspentTransactions {
               for _, out := range tx.Vout {
                       if out.CanBeUnlockedWith(address) {
                               UTXOs = append(UTXOs, out)
                       }
               }
       }

       return UTXOs
}
```

That’s it! Now we can implement `getbalance` command:
就是这样！现在我们可以执行 `getbalance` 命令了：

```go
func (cli *CLI) getBalance(address string) {
	bc := NewBlockchain(address)
	defer bc.db.Close()

	balance := 0
	UTXOs := bc.FindUTXO(address)

	for _, out := range UTXOs {
		balance += out.Value
	}

	fmt.Printf("Balance of '%s': %d\n", address, balance)
}
```

The account balance is the sum of values of all unspent transaction outputs locked by the account address.
账户余额是账户地址锁定的所有未用交易输出值的总和。

Let’s check our balance after mining the genesis block:
开采完创世区块后，让我们检查一下余额：

```shell
$ blockchain_go getbalance -address Ivan
Balance of 'Ivan': 10
```

This is our first money!
这是我们的第一笔钱！

### Sending Coins 发送硬币

Now, we want to send some coins to someone else. For this, we need to create a new transaction, put it in a block, and mine the block. So far, we implemented only the coinbase transaction (which is a special type of transactions), now we need a general transaction:
现在，我们想给别人发送一些币。为此，我们需要创建一个新的交易，将其放入一个区块中，并对该区块进行挖矿。到目前为止，我们只实现了 Coinbase 交易（这是一种特殊的交易类型），现在我们需要一种通用交易：

```go
func NewUTXOTransaction(from, to string, amount int, bc *Blockchain) *Transaction {
	var inputs []TXInput
	var outputs []TXOutput

	acc, validOutputs := bc.FindSpendableOutputs(from, amount)

	if acc < amount {
		log.Panic("ERROR: Not enough funds")
	}

	// Build a list of inputs
	for txid, outs := range validOutputs {
		txID, err := hex.DecodeString(txid)

		for _, out := range outs {
			input := TXInput{txID, out, from}
			inputs = append(inputs, input)
		}
	}

	// Build a list of outputs
	outputs = append(outputs, TXOutput{amount, to})
	if acc > amount {
		outputs = append(outputs, TXOutput{acc - amount, from}) // a change
	}

	tx := Transaction{nil, inputs, outputs}
	tx.SetID()

	return &tx
}
```

Before creating new outputs, we first have to find all unspent outputs and ensure that they store enough value. This is what `FindSpendableOutputs` method does. After that, for each found output an input referencing it is created. Next, we create two outputs:
在创建新的输出之前，我们首先要找到所有未使用的输出，并确保它们存储了足够的值。这就是 `FindSpendableOutputs` 方法的作用。然后，为每个找到的输出创建一个引用它的输入。接下来，我们创建两个输出：

1. One that’s locked with the receiver address. This is the actual transferring of coins to other address.
   一个与接收地址锁定的地址。这就是将硬币实际转移到其他地址的过程。
2. One that’s locked with the sender address. This is a change. It’s only created when unspent outputs hold more value than required for the new transaction. Remember: outputs are **indivisible**.
   一个与发件人地址锁定的地址。这是一种变化。只有当未使用的输出值超过新交易的需要时，才会产生这种变化。记住：输出是不可分割的。

```
FindSpendableOutputs` method is based on the `FindUnspentTransactions` method we defined earlier:
`FindSpendableOutputs` 方法基于我们之前定义的 方法： `FindUnspentTransactions
func (bc *Blockchain) FindSpendableOutputs(address string, amount int) (int, map[string][]int) {
	unspentOutputs := make(map[string][]int)
	unspentTXs := bc.FindUnspentTransactions(address)
	accumulated := 0

Work:
	for _, tx := range unspentTXs {
		txID := hex.EncodeToString(tx.ID)

		for outIdx, out := range tx.Vout {
			if out.CanBeUnlockedWith(address) && accumulated < amount {
				accumulated += out.Value
				unspentOutputs[txID] = append(unspentOutputs[txID], outIdx)

				if accumulated >= amount {
					break Work
				}
			}
		}
	}

	return accumulated, unspentOutputs
}
```

The method iterates over all unspent transactions and accumulates their values. When the accumulated value is more or equals to the amount we want to transfer, it stops and returns the accumulated value and output indices grouped by transaction IDs. We don’t want to take more than we’re going to spend.
该方法遍历所有未使用的交易，并累积其值。当累积值大于或等于我们要转账的金额时，它就会停止，并返回累积值和按交易 ID 分组的输出指数。我们不希望提取的金额超过我们要花费的金额。

Now we can modify the `Blockchain.MineBlock` method:
现在，我们可以修改 `Blockchain.MineBlock` 方法：

```go
func (bc *Blockchain) MineBlock(transactions []*Transaction) {
	...
	newBlock := NewBlock(transactions, lastHash)
	...
}
```

Finally, let’s implement `send` command:
最后，让我们执行 `send` 命令：

```go
func (cli *CLI) send(from, to string, amount int) {
	bc := NewBlockchain(from)
	defer bc.db.Close()

	tx := NewUTXOTransaction(from, to, amount, bc)
	bc.MineBlock([]*Transaction{tx})
	fmt.Println("Success!")
}
```

Sending coins means creating a transaction and adding it to the blockchain via mining a block. But Bitcoin doesn’t do this immediately (as we do). Instead, it puts all new transactions into memory pool (or mempool), and when a miner is ready to mine a block, it takes all transactions from the mempool and creates a candidate block. Transactions become confirmed only when a block containing them is mined and added to the blockchain.
发币意味着创建一笔交易，并通过挖掘一个区块将其添加到区块链中。但比特币不会立即这样做（就像我们一样）。相反，它会将所有新交易放入内存池（或内存池），当矿工准备好开采一个区块时，它会从内存池中提取所有交易并创建一个候选区块。只有当包含交易的区块被挖出并添加到区块链中时，交易才会被确认。

Let’s check that sending coins works:
让我们检查一下发送硬币是否有效：

```shell
$ blockchain_go send -from Ivan -to Pedro -amount 6
00000001b56d60f86f72ab2a59fadb197d767b97d4873732be505e0a65cc1e37

Success!

$ blockchain_go getbalance -address Ivan
Balance of 'Ivan': 4

$ blockchain_go getbalance -address Pedro
Balance of 'Pedro': 6
```

Nice! Now, let’s create more transactions and ensure that sending from multiple outputs works fine:
很好！现在，让我们创建更多的事务，确保从多个输出发送正常工作：

```shell
$ blockchain_go send -from Pedro -to Helen -amount 2
00000099938725eb2c7730844b3cd40209d46bce2c2af9d87c2b7611fe9d5bdf

Success!

$ blockchain_go send -from Ivan -to Helen -amount 2
000000a2edf94334b1d94f98d22d7e4c973261660397dc7340464f7959a7a9aa

Success!
```

Now, Helen’s coins are locked in two outputs: one from Pedro and one from Ivan. Let’s send them to someone else:
现在，海伦的硬币被锁定在两个输出端：一个来自佩德罗，一个来自伊万。让我们把它们发送给其他人：

```shell
$ blockchain_go send -from Helen -to Rachel -amount 3
000000c58136cffa669e767b8f881d16e2ede3974d71df43058baaf8c069f1a0

Success!

$ blockchain_go getbalance -address Ivan
Balance of 'Ivan': 2

$ blockchain_go getbalance -address Pedro
Balance of 'Pedro': 4

$ blockchain_go getbalance -address Helen
Balance of 'Helen': 1

$ blockchain_go getbalance -address Rachel
Balance of 'Rachel': 3
```

Looks fine! Now let’s test a failure:
看起来没问题！现在我们来测试一下失败：

```shell
$ blockchain_go send -from Pedro -to Ivan -amount 5
panic: ERROR: Not enough funds

$ blockchain_go getbalance -address Pedro
Balance of 'Pedro': 4

$ blockchain_go getbalance -address Ivan
Balance of 'Ivan': 2
```

### Conclusion 结论

Phew! It wasn’t easy, but we have transactions now! Although, some key features of a Bitcoin-like cryptocurrency are missing:
呼！虽然不容易，但我们现在有了交易！不过，类似比特币的加密货币还缺少一些关键功能：

1. Addresses. We don’t have real, private key based addresses yet.
   地址。我们还没有真正基于私钥的地址。
2. Rewards. Mining blocks is absolutely not profitable!
   奖励。开采区块绝对无利可图！
3. UTXO set. Getting balance requires scanning the whole blockchain, which can take very long time when there are many and many blocks. Also, it can take a lot of time if we want to validate later transactions. UTXO set is intended to solve these problems and make operations with transactions fast.
   UTXO设置。获取余额需要扫描整个区块链，当区块很多很多时，这可能需要很长时间。此外，如果我们要验证后面的交易，也会花费大量时间。UTXO集旨在解决这些问题，使交易操作更加快捷。
4. Mempool. This is where transactions are stored before being packed in a block. In our current implementation, a block contains only one transaction, and this is quite inefficient.
   内存池。在将事务打包到一个区块之前，事务就存储在这里。在我们目前的实现中，一个区块只包含一个事务，效率非常低。

Links: 链接

1. [Full source codes 完整源代码](https://github.com/Jeiwan/blockchain_go/tree/part_4)
2. [Transaction 交易](https://en.bitcoin.it/wiki/Transaction)
3. [Merkle tree 梅克尔树](https://en.bitcoin.it/wiki/Protocol_documentation#Merkle_Trees)
4. [Coinbase](https://en.bitcoin.it/wiki/Coinbase)



## Building Blockchain in Go. Part 5: Addresses

11 Sep 2017

> Chinese translations: [by liuchengxu](https://github.com/liuchengxu/blockchain-tutorial/blob/master/content/part-5/address.md), [by zhangli1](https://zhangli1.gitbooks.io/dummies-for-blockchain/content/)
> 中文翻译：刘成旭、张莉1

### Introduction 导言

In [the previous article](https://jeiwan.net/posts/building-blockchain-in-go-part-4/), we started implementing transactions. You were also introduced to the impersonal nature of transactions: there are no user accounts, your personal data (e.g., name, passport number or SSN) is not required and not stored anywhere in Bitcoin. But there still must be something that identifies you as the owner of transaction outputs (i.e. the owner of coins locked on these outputs). And this is what Bitcoin addresses are needed for. So far we’ve used arbitrary user defined strings as addresses, and the time has come to implement real addresses, as they’re implemented in Bitcoin.
在上一篇文章中，我们开始实施交易。我们也向您介绍了交易的非个人性质：没有用户账户，您的个人数据（如姓名、护照号码或 SSN）不需要，也不会存储在比特币中的任何地方。但是，仍然必须有一些东西可以确定你是交易输出的所有者（即锁定在这些输出上的币的所有者）。这就是比特币地址的作用。到目前为止，我们使用任意用户定义的字符串作为地址，现在是时候实现真正的地址了，就像在比特币中实现的那样。

> This part introduces significant code changes, so it makes no sense explaining all of them here. Please refer to [this page](https://github.com/Jeiwan/blockchain_go/compare/part_4...part_5#files_bucket) to see all the changes since the last article.
> 本部分引入了重要的代码更改，因此在此无法一一解释。请参阅本页，查看自上一篇文章以来的所有更改。

### Bitcoin Address 比特币地址

Here’s an example of a Bitcoin address: [1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa](https://blockchain.info/address/1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa). This is the very first Bitcoin address, which allegedly belongs to Satoshi Nakamoto. Bitcoin addresses are public. If you want to send coins to someone, you need to know their address. But addresses (despite being unique) are not something that identifies you as the owner of a “wallet”. In fact, such addresses are a human readable representation of public keys. In Bitcoin, your identity is a pair (or pairs) of private and public keys stored on your computer (or stored in some other place you have access to). Bitcoin relies on a combination of cryptography algorithms to create these keys, and guarantee that no one else in the world can access your coins without getting physical access to your keys. Let’s discuss what these algorithms are.
下面是一个比特币地址的例子：1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa.这是第一个比特币地址，据称属于中本聪。比特币地址是公开的。如果你想给某人发送比特币，你需要知道他的地址。但是，地址（尽管是唯一的）并不能证明你是 "钱包 "的所有者。事实上，这种地址是公钥的人可读表示。在比特币中，你的身份是一对（或多对）私钥和公钥，它们存储在你的电脑中（或存储在你可以访问的其他地方）。比特币依靠密码学算法的组合来创建这些密钥，并保证世界上没有其他人可以在不实际接触到你的密钥的情况下接触到你的币。让我们来讨论一下这些算法是什么。

### Public-key Cryptography 公钥密码学

Public-key cryptography algorithms use pairs of keys: public keys and private keys. Public keys are not sensitive and can be disclosed to anyone. In contrast, private keys shouldn’t be disclosed: no one but the owner should have access to them because it’s private keys that serve as the identifier of the owner. You are your private keys (in the world of cryptocurrencies, of course).
公钥加密算法使用成对的密钥：公钥和私钥。公开密钥并不敏感，可以向任何人公开。相比之下，私钥则不应该公开：除了所有者，任何人都不应该获取私钥，因为私钥是所有者的身份标识。你就是你的私人密钥（当然是在加密货币的世界里）。

In essence, a Bitcoin wallet is just a pair of such keys. When you install a wallet application or use a Bitcoin client to generate a new address, a pair of keys is generated for you. The one who controls the private key controls all the coins sent to this key in Bitcoin.
从本质上讲，比特币钱包就是一对这样的密钥。当你安装一个钱包应用程序或使用比特币客户端生成一个新地址时，就会为你生成一对密钥。谁控制了私钥，谁就控制了比特币中发送到这个私钥的所有币。

Private and public keys are just random sequences of bytes, thus they cannot be printed on the screen and read by a human. That’s why Bitcoin uses an algorithm to convert public keys into a human readable string.
私钥和公钥只是随机的字节序列，因此无法打印在屏幕上，也无法被人类读取。这就是比特币使用算法将公钥转换成人类可读字符串的原因。

> If you’ve ever used a Bitcoin wallet application, it’s likely that a mnemonic pass phrase was generated for you. Such phrases are used instead of private keys and can be used to generate them. This mechanism is implemented in [BIP-039](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki).
> 如果你曾经使用过比特币钱包应用程序，很可能会为你生成一个助记通行短语。这种短语可以用来代替私钥，也可以用来生成私钥。BIP-039 实现了这种机制。

Ok, we now know what identifies users in Bitcoin. But how does Bitcoin check the ownership of transaction outputs (and coins stored on them)?
好了，我们现在知道了什么是比特币用户的身份识别。但是，比特币如何检查交易输出（以及存储在交易输出上的币）的所有权呢？

### Digital Signatures 数字签名

In mathematics and cryptography, there’s a concept of digital signature – algorithms that guarantee:
在数学和密码学中，有一个数字签名的概念，即保证数字签名的算法：

1. that data wasn’t modified while being transferred from a sender to a recipient;
   确保数据在从发件人传输到收件人的过程中没有被修改；
2. that data was created by a certain sender;
   该数据是由某个发送者创建的；
3. that the sender cannot deny sending the data.
   发送方不能拒绝发送数据。

By applying a signing algorithm to data (i.e., signing the data), one gets a signature, which can later be verified. Digital signing happens with the usage of a private key, and verification requires a public key.
通过对数据应用签名算法（即对数据进行签名），可以得到一个签名，随后可以对其进行验证。数字签名需要使用私钥，而验证则需要使用公钥。

In order to sign data we need the following things:
为了签署数据，我们需要以下东西：

1. data to sign; 签署数据；
2. private key. 私钥。

The operation of signing produces a signature, which is stored in transaction inputs. In order to verify a signature, the following is required:
签名操作产生一个签名，存储在交易输入中。要验证签名，需要满足以下条件：

1. data that was signed;
   已签署的数据；
2. the signature; 签名；
3. public key. 公共密钥。

In simple terms, the verification process can be described as: check that this signature was obtained from this data with a private key used to generate the public key.
简单来说，验证过程可以描述为：检查该签名是否是用生成公钥的私钥从该数据中获取的。

> Digital signatures are not encryption, you cannot reconstruct the data from a signature. This is similar to hashing: you run data through a hashing algorithm and get a unique representation of the data. The difference between signatures and hashes is key pairs: they make signature verification possible.
> 数字签名不是加密，你无法根据签名重建数据。这与哈希算法类似：通过哈希算法运行数据，可以得到数据的唯一表示。签名与哈希算法的区别在于密钥对：密钥对使签名验证成为可能。
> But key pairs can also be used to encrypt data: a private key is used to encrypt, and a public key is used to decrypt the data. Bitcoin doesn’t use encryption algorithms though.
> 但是密钥对也可以用来加密数据：私钥用来加密，公钥用来解密。但比特币不使用加密算法。

Every transaction input in Bitcoin is signed by the one who created the transaction. Every transaction in Bitcoin must be verified before being put in a block. Verification means (besides other procedures):
在比特币中输入的每一笔交易都由创建交易的人签名。比特币中的每笔交易都必须经过验证，才能放入区块中。验证意味着（除其他程序外）：

1. Checking that inputs have permission to use outputs from previous transactions.
   检查输入是否允许使用以前交易的输出。
2. Checking that the transaction signature is correct.
   检查交易签名是否正确。

Schematically, the process of signing data and verifying signature looks likes this:
从原理上讲，签署数据和验证签名的过程是这样的：

![Digital Signatures](https://jeiwan.net/images/signing-scheme.png)

Let’s now review the full lifecycle of a transaction:
现在让我们回顾一下交易的整个生命周期：

1. In the beginning, there’s the genesis block that contains a coinbase transaction. There are no real inputs in coinbase transactions, so signing is not necessary. The output of the coinbase transaction contains a hashed public key (`RIPEMD16(SHA256(PubKey))` algorithms are used).
   一开始，创世区块包含了一个币安交易。币安交易中没有真正的输入，因此无需签名。Coinbase 交易的输出包含哈希公钥（使用 `RIPEMD16(SHA256(PubKey))` 算法）。
2. When one sends coins, a transaction is created. Inputs of the transaction will reference outputs from previous transaction(s). Every input will store a public key (not hashed) and a signature of the whole transaction.
   当一个人发送硬币时，就创建了一个交易。交易的输入将参考之前交易的输出。每个输入将存储一个公钥（非散列）和整个交易的签名。
3. Other nodes in the Bitcoin network that receive the transaction will verify it. Besides other things, they will check that: the hash of the public key in an input matches the hash of the referenced output (this ensures that the sender spends only coins belonging to them); the signature is correct (this ensures that the transaction is created by the real owner of the coins).
   比特币网络中的其他节点收到交易后会进行验证。除其他事项外，它们还将检查：输入中公钥的哈希值是否与引用输出的哈希值相匹配（这可确保发送者只使用属于自己的硬币）；签名是否正确（这可确保交易是由硬币的真正所有者创建的）。
4. When a miner node is ready to mine a new block, it’ll put the transaction in a block and start mining it.
   当矿工节点准备好开采一个新区块时，它就会将交易放入一个区块并开始开采。
5. When the blocked is mined, every other node in the network receives a message saying the block is mined and adds the block to the blockchain.
   当区块被挖出时，网络中的其他节点都会收到一条信息，说明该区块已被挖出，并将该区块添加到区块链中。
6. After a block is added to the blockchain, the transaction is completed, its outputs can be referenced in new transactions.
   一个区块添加到区块链后，交易就完成了，其输出可以在新的交易中被引用。

### Elliptic Curve Cryptography 椭圆曲线密码学

As described above, public and private keys are sequences of random bytes. Since it’s private keys that are used to identify owners of coins, there’s a required condition: the randomness algorithm must produce truly random bytes. We don’t want to accidentally generate a private key that’s owned by someone else.
如上所述，公钥和私钥都是随机字节序列。由于私钥是用来识别硬币所有者的，因此有一个必要条件：随机性算法必须产生真正的随机字节。我们可不想意外生成一把别人拥有的私钥。

Bitcoin uses elliptic curves to generate private keys. Elliptic curves is a complex mathematical concept, which we’re not going to explain in details here (if you’re curious, check out [this gentle introduction to elliptic curves](http://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/) WARNING: Math formulas!). What we need to know is that these curves can be used to generate really big and random numbers. The curve used by Bitcoin can randomly pick a number between 0 and 2²⁵⁶ (which is approximately 10⁷⁷, when there are between 10⁷⁸ and 10⁸² atoms in the visible universe). Such a huge upper limit means that it’s almost impossible to generate the same private key twice.
比特币使用椭圆曲线生成私钥。椭圆曲线是一个复杂的数学概念，我们在这里就不详细解释了（如果你好奇，可以看看这篇关于椭圆曲线的温和介绍，警告：数学公式！）。我们需要知道的是，这些曲线可以用来生成非常大的随机数。比特币使用的曲线可以随机选择 0 到 2²⁵⁶ 之间的数字（约等于 10⁷⁷，而可见宇宙中的原子数量在 10⁷⁸ 和 10⁸² 之间）。如此大的上限意味着几乎不可能生成两次相同的私钥。

Also, Bitcoin uses (and we will) ECDSA (Elliptic Curve Digital Signature Algorithm) algorithm to sign transactions.
此外，比特币使用（我们也将使用）ECDSA（椭圆曲线数字签名算法）来签署交易。

### Base58 基地58

Now let’s get back to the above mentioned Bitcoin address: 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa. Now we know that this is a human-readable representation of a public key. And if we decode it, here’s what the public key looks like (as a sequence of bytes written in the hexadecimal system):
现在让我们回到上面提到的比特币地址：1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa.现在我们知道，这是一个公钥的人可读表示法。如果我们对其进行解码，下面就是公钥的样子（以十六进制写成的字节序列）：

```shell
0062E907B15CBF27D5425399EBF6F0FB50EBB88F18C29B7D93
```

Bitcoin uses the Base58 algorithm to convert public keys into human readable format. The algorithm is very similar to famous Base64, but it uses shorter alphabet: some letters were removed from the alphabet to avoid some attacks that use letters similarity. Thus, there are no these symbols: 0 (zero), O (capital o), I (capital i), l (lowercase L), because they look similar. Also, there are no + and / symbols.
比特币使用 Base58 算法将公钥转换成人类可读的格式。该算法与著名的 Base64 算法非常相似，但它使用的字母表更短：从字母表中删除了一些字母，以避免一些使用字母相似性的攻击。因此，没有这些符号：0（零）、O（大写 o）、I（大写 i）、L（小写 L），因为它们看起来很相似。此外，也没有 + 和 / 符号。

Let’s schematically visualize the process of getting an address from a public key:
让我们用示意图直观地展示一下从公钥获取地址的过程：

![Address Generation](https://jeiwan.net/images/address-generation-scheme.png)

Thus, the above mentioned decoded public key consists of three parts:
因此，上述解码后的公开密钥由三部分组成：

```shell
Version  Public key hash                           Checksum
00       62E907B15CBF27D5425399EBF6F0FB50EBB88F18  C29B7D93
```

Since hashing functions are one way (i.e., they cannot be reversed), it’s not possible to extract the public key from the hash. But we can check if a public key was used to get the hash by running it thought the save hash functions and comparing the hashes.
由于哈希函数是单向的（即无法逆转），因此无法从哈希值中提取公钥。但我们可以通过运行保存的哈希函数并比较哈希值来检查是否使用了公钥获取哈希值。

Ok, now that we have all the pieces, let’s write some code. Some of the concepts should be more clear when written in code.
好了，现在我们已经掌握了所有的知识，让我们来写一些代码吧。有些概念用代码写出来会更清楚。

### Implementing Addresses 执行地址

We’ll start with the `Wallet` structure:
我们将从 `Wallet` 结构开始：

```go
type Wallet struct {
	PrivateKey ecdsa.PrivateKey
	PublicKey  []byte
}

type Wallets struct {
	Wallets map[string]*Wallet
}

func NewWallet() *Wallet {
	private, public := newKeyPair()
	wallet := Wallet{private, public}

	return &wallet
}

func newKeyPair() (ecdsa.PrivateKey, []byte) {
	curve := elliptic.P256()
	private, err := ecdsa.GenerateKey(curve, rand.Reader)
	pubKey := append(private.PublicKey.X.Bytes(), private.PublicKey.Y.Bytes()...)

	return *private, pubKey
}
```

A wallet is nothing but a key pair. We’ll also need the `Wallets` type to keep a collection of wallets, save them to a file, and load them from it. In the construction function of `Wallet` a new key pair is generated. The `newKeyPair` function is straightforward: ECDSA is based on elliptic curves, so we need one. Next, a private key is generated using the curve, and a public key is generated from the private key. One thing to notice: in elliptic curve based algorithms, public keys are points on a curve. Thus, a public key is a combination of X, Y coordinates. In Bitcoin, these coordinates are concatenated and form a public key.
钱包只是一个密钥对。我们还需要 `Wallets` 类型来保存钱包集合，将它们保存到文件中，并从文件中加载它们。在 `Wallet` 的构造函数中，会生成一个新的密钥对。 `newKeyPair` 函数非常简单：ECDSA 基于椭圆曲线，因此我们需要一个椭圆曲线。接下来，使用椭圆曲线生成私钥，再根据私钥生成公钥。需要注意的一点是：在基于椭圆曲线的算法中，公钥是曲线上的点。因此，公钥是 X、Y 坐标的组合。在比特币中，这些坐标被连接起来，形成一个公钥。

Now, let’s generate an address:
现在，让我们生成一个地址：

```go
func (w Wallet) GetAddress() []byte {
	pubKeyHash := HashPubKey(w.PublicKey)

	versionedPayload := append([]byte{version}, pubKeyHash...)
	checksum := checksum(versionedPayload)

	fullPayload := append(versionedPayload, checksum...)
	address := Base58Encode(fullPayload)

	return address
}

func HashPubKey(pubKey []byte) []byte {
	publicSHA256 := sha256.Sum256(pubKey)

	RIPEMD160Hasher := ripemd160.New()
	_, err := RIPEMD160Hasher.Write(publicSHA256[:])
	publicRIPEMD160 := RIPEMD160Hasher.Sum(nil)

	return publicRIPEMD160
}

func checksum(payload []byte) []byte {
	firstSHA := sha256.Sum256(payload)
	secondSHA := sha256.Sum256(firstSHA[:])

	return secondSHA[:addressChecksumLen]
}
```

Here are the steps to convert a public key into a Base58 address:
以下是将公钥转换为 Base58 地址的步骤：

1. Take the public key and hash it twice with `RIPEMD160(SHA256(PubKey))` hashing algorithms.
   使用 `RIPEMD160(SHA256(PubKey))` 哈希算法对公钥进行两次哈希。
2. Prepend the version of the address generation algorithm to the hash.
   在哈希值前加上地址生成算法的版本。
3. Calculate the checksum by hashing the result of step 2 with `SHA256(SHA256(payload))`. The checksum is the first four bytes of the resulted hash.
   用 `SHA256(SHA256(payload))` 对步骤 2 的结果进行散列，计算校验和。校验和是散列结果的前四个字节。
4. Append the checksum to the `version+PubKeyHash` combination.
   将校验和附加到 `version+PubKeyHash` 组合中。
5. Encode the `version+PubKeyHash+checksum` combination with Base58.
   使用 Base58 对 `version+PubKeyHash+checksum` 组合进行编码。

As a result, you’ll get a **real Bitcoin address**, you can even check its balance on [blockchain.info](https://blockchain.info/). But I can assure you that the balance is 0 no matter how many times you generate a new address and check its balance. This is why choosing proper public-key cryptography algorithm is so crucial: considering private keys are random numbers, the chance of generating the same number must be as low as possible. Ideally, it must be as low as “never”.
这样，你就会得到一个真实的比特币地址，你甚至可以在 blockchain.info 上查看它的余额。但我可以向你保证，无论你生成多少次新地址并查看其余额，余额都是 0。这就是为什么选择合适的公钥加密算法如此重要：考虑到私钥是随机数，生成相同数字的几率必须尽可能低。理想情况下，必须低至 "永远不会"。

Also, pay attention that you don’t need to connect to a Bitcoin node to get an address. The address generation algorithm utilizes a combination of open algorithms that are implemented in many programming languages and libraries.
另外要注意的是，获取地址并不需要连接到比特币节点。地址生成算法利用了多种开放算法的组合，这些算法在许多编程语言和程序库中都能实现。

Now we need to modify inputs and outputs for them to use addresses:
现在，我们需要修改输入和输出，以便它们使用地址：

```go
type TXInput struct {
	Txid      []byte
	Vout      int
	Signature []byte
	PubKey    []byte
}

func (in *TXInput) UsesKey(pubKeyHash []byte) bool {
	lockingHash := HashPubKey(in.PubKey)

	return bytes.Compare(lockingHash, pubKeyHash) == 0
}

type TXOutput struct {
	Value      int
	PubKeyHash []byte
}

func (out *TXOutput) Lock(address []byte) {
	pubKeyHash := Base58Decode(address)
	pubKeyHash = pubKeyHash[1 : len(pubKeyHash)-4]
	out.PubKeyHash = pubKeyHash
}

func (out *TXOutput) IsLockedWithKey(pubKeyHash []byte) bool {
	return bytes.Compare(out.PubKeyHash, pubKeyHash) == 0
}
```

Notice, that we’re no longer using `ScriptPubKey` and `ScriptSig` fields, because we’re not going to implement a scripting language. Instead, `ScriptSig` is split into `Signature` and `PubKey` fields, and `ScriptPubKey` is renamed to `PubKeyHash`. We’ll implement the same outputs locking/unlocking and inputs signing logics as in Bitcoin, but we’ll do this in methods instead.
请注意，我们不再使用 `ScriptPubKey` 和 `ScriptSig` 字段，因为我们不打算实现脚本语言。取而代之的是， `ScriptSig` 分成 `Signature` 和 `PubKey` 两个字段， `ScriptPubKey` 更名为 `PubKeyHash` 。我们将实现与比特币相同的输出锁定/解锁和输入签名逻辑，但我们将在方法中实现。

The `UsesKey` method checks that an input uses a specific key to unlock an output. Notice that inputs store raw public keys (i.e., not hashed), but the function takes a hashed one. `IsLockedWithKey` checks if provided public key hash was used to lock the output. This is a complementary function to `UsesKey`, and they’re both used in `FindUnspentTransactions` to build connections between transactions.
`UsesKey` 方法会检查输入是否使用了特定的密钥来解锁输出。请注意，输入存储的是原始公钥（即未散列），而函数使用的是散列公钥。 `IsLockedWithKey` 会检查所提供的公钥散列值是否用于锁定输出。这是 `UsesKey` 的补充函数，它们都在 `FindUnspentTransactions` 中用于建立事务之间的连接。

```
Lock` simply locks an output. When we send coins to someone, we know only their address, thus the function takes an address as the only argument. The address is then decoded and the public key hash is extracted from it and saved in the `PubKeyHash` field.
`Lock` 只需锁定一个输出。当我们向某人发送硬币时，我们只知道他的地址，因此函数将地址作为唯一的参数。然后对地址进行解码，从中提取公钥哈希值并保存在 字段中。 `PubKeyHash
```

Now, let’s check that everything works correctly:
现在，让我们检查一下一切运行是否正常：

```shell
$ blockchain_go createwallet
Your new address: 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt

$ blockchain_go createwallet
Your new address: 15pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5h

$ blockchain_go createwallet
Your new address: 1Lhqun1E9zZZhodiTqxfPQBcwr1CVDV2sy

$ blockchain_go createblockchain -address 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt
0000005420fbfdafa00c093f56e033903ba43599fa7cd9df40458e373eee724d

Done!

$ blockchain_go getbalance -address 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt
Balance of '13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt': 10

$ blockchain_go send -from 15pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5h -to 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt -amount 5
2017/09/12 13:08:56 ERROR: Not enough funds

$ blockchain_go send -from 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt -to 15pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5h -amount 6
00000019afa909094193f64ca06e9039849709f5948fbac56cae7b1b8f0ff162

Success!

$ blockchain_go getbalance -address 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt
Balance of '13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt': 4

$ blockchain_go getbalance -address 15pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5h
Balance of '15pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5h': 6

$ blockchain_go getbalance -address 1Lhqun1E9zZZhodiTqxfPQBcwr1CVDV2sy
Balance of '1Lhqun1E9zZZhodiTqxfPQBcwr1CVDV2sy': 0
```

Nice! Now let’s implement transaction signatures.
不错！现在我们来实现交易签名。

### Implementing Signatures 实施签名

Transactions must be signed because this is the only way in Bitcoin to guarantee that one cannot spend coins belonging to someone else. If a signature is invalid, the transaction is considered invalid too and, thus, cannot be added to the blockchain.
交易必须签名，因为在比特币中，只有这样才能保证不会花掉属于别人的币。如果签名无效，交易也将被视为无效，因此不能添加到区块链中。

We have all the pieces to implement transactions signing, except one thing: data to sign. What parts of a transaction are actually signed? Or a transaction is signed as a whole? Choosing data to sign is quite important. The thing is that data to be signed must contain information that identifies the data in a unique way. For example, it makes no sense signing just output values because such signature won’t consider the sender and the recipient.
我们已经具备了实现事务签名的所有要素，但还差一样东西：需要签名的数据。交易的哪些部分需要签名？还是整个事务都要签名？选择要签名的数据相当重要。要签名的数据必须包含能以独特方式识别数据的信息。例如，只签署输出值是没有意义的，因为这样的签名不会考虑发送方和接收方。

Considering that transactions unlock previous outputs, redistribute their values, and lock new outputs, the following data must be signed:
考虑到事务会解锁先前的输出、重新分配其值并锁定新的输出，因此必须对以下数据进行签名：

1. Public key hashes stored in unlocked outputs. This identifies “sender” of a transaction.
   存储在解锁输出中的公钥哈希值。这可以识别交易的 "发送方"。
2. Public key hashes stored in new, locked, outputs. This identifies “recipient” of a transaction.
   公钥哈希值存储在新的锁定输出中。这可以识别交易的 "接收者"。
3. Values of new outputs.
   新产出的值。

> In Bitcoin, locking/unlocking logic is stored in scripts, which are stored in `ScriptSig` and `ScriptPubKey` fields of inputs and outputs, respectively. Since Bitcoins allows different types of such scripts, it signs the whole content of `ScriptPubKey`.
> 在比特币中，锁定/解锁逻辑存储在脚本中，脚本分别存储在输入和输出的 `ScriptSig` 和 `ScriptPubKey` 字段中。由于比特币允许不同类型的此类脚本，因此它可以对 `ScriptPubKey` 的全部内容进行签名。

As you can see, we don’t need to sign the public keys stored in inputs. Because of this, in Bitcoin, it’s not a transaction that’s signed, but its trimmed copy with inputs storing `ScriptPubKey` from referenced outputs.
正如你所看到的，我们不需要签署存储在输入中的公钥。正因为如此，在比特币中，被签名的不是交易，而是其经过修剪的副本，其输入存储了来自引用输出的 `ScriptPubKey` 。

> A detailed process of getting a trimmed transaction copy is described [here](https://en.bitcoin.it/wiki/File:Bitcoin_OpCheckSig_InDetail.png). It’s likely to be outdated, but I didn’t manage to find a more reliable source of information.
> 这里描述了获取经过修剪的交易副本的详细过程。这很可能已经过时，但我没有找到更可靠的信息来源。

Ok, it looks complicated, so let’s start coding. We’ll start with the `Sign` method:
好了，看起来很复杂，让我们开始编码吧。我们从 `Sign` 方法开始：

```go
func (tx *Transaction) Sign(privKey ecdsa.PrivateKey, prevTXs map[string]Transaction) {
	if tx.IsCoinbase() {
		return
	}

	txCopy := tx.TrimmedCopy()

	for inID, vin := range txCopy.Vin {
		prevTx := prevTXs[hex.EncodeToString(vin.Txid)]
		txCopy.Vin[inID].Signature = nil
		txCopy.Vin[inID].PubKey = prevTx.Vout[vin.Vout].PubKeyHash
		txCopy.ID = txCopy.Hash()
		txCopy.Vin[inID].PubKey = nil

		r, s, err := ecdsa.Sign(rand.Reader, &privKey, txCopy.ID)
		signature := append(r.Bytes(), s.Bytes()...)

		tx.Vin[inID].Signature = signature
	}
}
```

The method takes a private key and a map of previous transactions. As mentioned above, in order to sign a transaction, we need to access the outputs referenced in the inputs of the transaction, thus we need the transactions that store these outputs.
该方法需要一个私钥和一个先前事务的映射。如上所述，为了签署事务，我们需要访问事务输入中引用的输出，因此我们需要存储这些输出的事务。

Let’s review this method step by step:
让我们逐步回顾一下这种方法：

```go
if tx.IsCoinbase() {
	return
}
```

Coinbase transactions are not signed because there are no real inputs in them.
Coinbase 交易没有签名，因为其中没有真实输入。

```go
txCopy := tx.TrimmedCopy()
```

A trimmed copy will be signed, not a full transaction:
将签署修剪过的副本，而不是完整的交易：

```go
func (tx *Transaction) TrimmedCopy() Transaction {
	var inputs []TXInput
	var outputs []TXOutput

	for _, vin := range tx.Vin {
		inputs = append(inputs, TXInput{vin.Txid, vin.Vout, nil, nil})
	}

	for _, vout := range tx.Vout {
		outputs = append(outputs, TXOutput{vout.Value, vout.PubKeyHash})
	}

	txCopy := Transaction{tx.ID, inputs, outputs}

	return txCopy
}
```

The copy will include all the inputs and outputs, but `TXInput.Signature` and `TXInput.PubKey` are set to nil.
副本将包括所有输入和输出，但 `TXInput.Signature` 和 `TXInput.PubKey` 设置为零。

Next, we iterate over each input in the copy:
接下来，我们遍历副本中的每个输入：

```go
for inID, vin := range txCopy.Vin {
	prevTx := prevTXs[hex.EncodeToString(vin.Txid)]
	txCopy.Vin[inID].Signature = nil
	txCopy.Vin[inID].PubKey = prevTx.Vout[vin.Vout].PubKeyHash
```

In each input, `Signature` is set to `nil` (just a double-check) and `PubKey` is set to the `PubKeyHash` of the referenced output. At this moment, all transactions but the current one are “empty”, i.e. their `Signature` and `PubKey` fields are set to nil. Thus, **inputs are signed separately**, although this is not necessary for our application, but Bitcoin allows transactions to contain inputs referencing different addresses.
在每个输入中， `Signature` 设置为 `nil` （只是重复检查）， `PubKey` 设置为引用输出的 `PubKeyHash` 。此时，除当前交易外的所有交易都是 "空 "的，即其 `Signature` 和 `PubKey` 字段被设置为零。因此，输入是单独签名的，虽然这对我们的应用来说不是必须的，但比特币允许交易包含引用不同地址的输入。

```go
	txCopy.ID = txCopy.Hash()
	txCopy.Vin[inID].PubKey = nil
```

The `Hash` method serializes the transaction and hashes it with the SHA-256 algorithm. The resulted hash is the data we’re going to sign. After getting the hash we should reset the `PubKey` field, so it doesn’t affect further iterations.
`Hash` 方法将事务序列化，并使用 SHA-256 算法对其进行散列。散列结果就是我们要签名的数据。获取哈希值后，我们应重置 `PubKey` 字段，以免影响后续迭代。

Now, the central piece:
现在是中心部分：

```go
	r, s, err := ecdsa.Sign(rand.Reader, &privKey, txCopy.ID)
	signature := append(r.Bytes(), s.Bytes()...)

	tx.Vin[inID].Signature = signature
```

We sign `txCopy.ID` with `privKey`. An ECDSA signature is a pair of numbers, which we concatenate and store in the input’s `Signature` field.
我们使用 `privKey` 对 `txCopy.ID` 进行签名。ECDSA 签名是一对数字，我们将其连接起来并存储在输入的 `Signature` 字段中。

Now, the verification function:
现在是验证功能：

```go
func (tx *Transaction) Verify(prevTXs map[string]Transaction) bool {
	txCopy := tx.TrimmedCopy()
	curve := elliptic.P256()

	for inID, vin := range tx.Vin {
		prevTx := prevTXs[hex.EncodeToString(vin.Txid)]
		txCopy.Vin[inID].Signature = nil
		txCopy.Vin[inID].PubKey = prevTx.Vout[vin.Vout].PubKeyHash
		txCopy.ID = txCopy.Hash()
		txCopy.Vin[inID].PubKey = nil

		r := big.Int{}
		s := big.Int{}
		sigLen := len(vin.Signature)
		r.SetBytes(vin.Signature[:(sigLen / 2)])
		s.SetBytes(vin.Signature[(sigLen / 2):])

		x := big.Int{}
		y := big.Int{}
		keyLen := len(vin.PubKey)
		x.SetBytes(vin.PubKey[:(keyLen / 2)])
		y.SetBytes(vin.PubKey[(keyLen / 2):])

		rawPubKey := ecdsa.PublicKey{curve, &x, &y}
		if ecdsa.Verify(&rawPubKey, txCopy.ID, &r, &s) == false {
			return false
		}
	}

	return true
}
```

The method is quite straightforward. First, we need the same transaction copy:
方法非常简单。首先，我们需要相同的事务副本：

```go
txCopy := tx.TrimmedCopy()
```

Next, we’ll need the same curve that is used to generate key pairs:
接下来，我们需要与生成密钥对相同的曲线：

```go
curve := elliptic.P256()
```

Next, we check signature in each input:
接下来，我们检查每个输入的签名：

```go
for inID, vin := range tx.Vin {
	prevTx := prevTXs[hex.EncodeToString(vin.Txid)]
	txCopy.Vin[inID].Signature = nil
	txCopy.Vin[inID].PubKey = prevTx.Vout[vin.Vout].PubKeyHash
	txCopy.ID = txCopy.Hash()
	txCopy.Vin[inID].PubKey = nil
```

This piece is identical to the one in the `Sign` method, because during verification we need the same data what was signed.
这部分内容与 `Sign` 方法中的内容相同，因为在验证过程中，我们需要与签名相同的数据。

```go
	r := big.Int{}
	s := big.Int{}
	sigLen := len(vin.Signature)
	r.SetBytes(vin.Signature[:(sigLen / 2)])
	s.SetBytes(vin.Signature[(sigLen / 2):])

	x := big.Int{}
	y := big.Int{}
	keyLen := len(vin.PubKey)
	x.SetBytes(vin.PubKey[:(keyLen / 2)])
	y.SetBytes(vin.PubKey[(keyLen / 2):])
```

Here we unpack values stored in `TXInput.Signature` and `TXInput.PubKey`, since a signature is a pair of numbers and a public key is a pair of coordinates. We concatenated them earlier for storing, and now we need to unpack them to use in `crypto/ecdsa` functions.
在此，我们将解压存储在 `TXInput.Signature` 和 `TXInput.PubKey` 中的值，因为签名是一对数字，而公钥是一对坐标。我们之前将它们连接起来进行存储，现在我们需要将它们解压缩，以便在 `crypto/ecdsa` 函数中使用。

```go
	rawPubKey := ecdsa.PublicKey{curve, &x, &y}
	if ecdsa.Verify(&rawPubKey, txCopy.ID, &r, &s) == false {
		return false
	}
}

return true
```

Here it is: we create an `ecdsa.PublicKey` using the public key extracted from the input and execute `ecdsa.Verify` passing the signature extracted from the input. If all inputs are verified, return true; if at least one input fails verification, return false.
就是这样：我们使用从输入中提取的公钥创建 `ecdsa.PublicKey` ，并通过从输入中提取的签名执行 `ecdsa.Verify` 。如果所有输入都通过验证，则返回 true；如果至少有一个输入未通过验证，则返回 false。

Now, we need a function to obtain previous transactions. Since this requires interaction with the blockchain, we’ll make it a method of `Blockchain`:
现在，我们需要一个函数来获取之前的交易。由于这需要与区块链交互，我们将把它作为 `Blockchain` 的一个方法：

```go
func (bc *Blockchain) FindTransaction(ID []byte) (Transaction, error) {
	bci := bc.Iterator()

	for {
		block := bci.Next()

		for _, tx := range block.Transactions {
			if bytes.Compare(tx.ID, ID) == 0 {
				return *tx, nil
			}
		}

		if len(block.PrevBlockHash) == 0 {
			break
		}
	}

	return Transaction{}, errors.New("Transaction is not found")
}

func (bc *Blockchain) SignTransaction(tx *Transaction, privKey ecdsa.PrivateKey) {
	prevTXs := make(map[string]Transaction)

	for _, vin := range tx.Vin {
		prevTX, err := bc.FindTransaction(vin.Txid)
		prevTXs[hex.EncodeToString(prevTX.ID)] = prevTX
	}

	tx.Sign(privKey, prevTXs)
}

func (bc *Blockchain) VerifyTransaction(tx *Transaction) bool {
	prevTXs := make(map[string]Transaction)

	for _, vin := range tx.Vin {
		prevTX, err := bc.FindTransaction(vin.Txid)
		prevTXs[hex.EncodeToString(prevTX.ID)] = prevTX
	}

	return tx.Verify(prevTXs)
}
```

These functions are simple: `FindTransaction` finds a transaction by ID (this requires iterating over all the blocks in the blockchain); `SignTransaction` takes a transaction, finds transactions it references, and signs it; `VerifyTransaction` does the same, but verifies the transaction instead.
这些函数非常简单： `FindTransaction` 通过 ID 查找交易（这需要遍历区块链中的所有区块）； `SignTransaction` 获取交易，查找它所引用的交易，并对其进行签名； `VerifyTransaction` 执行相同的操作，但对交易进行验证。

Now, we need to actually sign and verify transactions. Signing happens in the `NewUTXOTransaction`:
现在，我们需要实际签署和验证交易。签名发生在 `NewUTXOTransaction` .NET：

```go
func NewUTXOTransaction(from, to string, amount int, bc *Blockchain) *Transaction {
	...

	tx := Transaction{nil, inputs, outputs}
	tx.ID = tx.Hash()
	bc.SignTransaction(&tx, wallet.PrivateKey)

	return &tx
}
```

Verification happens before a transaction is put into a block:
验证发生在交易被放入区块之前：

```go
func (bc *Blockchain) MineBlock(transactions []*Transaction) {
	var lastHash []byte

	for _, tx := range transactions {
		if bc.VerifyTransaction(tx) != true {
			log.Panic("ERROR: Invalid transaction")
		}
	}
	...
}
```

And that’s it! Let’s check everything one more time:
就是这样！让我们再检查一遍：

```shell
$ blockchain_go createwallet
Your new address: 1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR

$ blockchain_go createwallet
Your new address: 1NE86r4Esjf53EL7fR86CsfTZpNN42Sfab

$ blockchain_go createblockchain -address 1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR
000000122348da06c19e5c513710340f4c307d884385da948a205655c6a9d008

Done!

$ blockchain_go send -from 1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR -to 1NE86r4Esjf53EL7fR86CsfTZpNN42Sfab -amount 6
0000000f3dbb0ab6d56c4e4b9f7479afe8d5a5dad4d2a8823345a1a16cf3347b

Success!

$ blockchain_go getbalance -address 1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR
Balance of '1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR': 4

$ blockchain_go getbalance -address 1NE86r4Esjf53EL7fR86CsfTZpNN42Sfab
Balance of '1NE86r4Esjf53EL7fR86CsfTZpNN42Sfab': 6
```

Nothing is broken. Awesome!
没有任何破损。真棒

Let’s also comment out the `bc.SignTransaction(&tx, wallet.PrivateKey)` call in `NewUTXOTransaction` to ensure that unsigned transactions cannot be mined:
我们还要注释掉 `NewUTXOTransaction` 中的 `bc.SignTransaction(&tx, wallet.PrivateKey)` 调用，以确保未签名的交易无法被挖掘：

```go
func NewUTXOTransaction(from, to string, amount int, bc *Blockchain) *Transaction {
   ...
	tx := Transaction{nil, inputs, outputs}
	tx.ID = tx.Hash()
	// bc.SignTransaction(&tx, wallet.PrivateKey)

	return &tx
}
$ go install
$ blockchain_go send -from 1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR -to 1NE86r4Esjf53EL7fR86CsfTZpNN42Sfab -amount 1
2017/09/12 16:28:15 ERROR: Invalid transaction
```

### Conclusion 结论

It’s really awesome that we’ve got so far and implemented so many key features of Bitcoin! We’ve implemented almost everything outside networking, and in the next part, we’ll finish transactions.
到目前为止，我们已经实现了比特币的许多关键功能，这真是太棒了！在下一部分，我们将完成交易。

Links: 链接

1. [Full source codes 完整源代码](https://github.com/Jeiwan/blockchain_go/tree/part_5)
2. [Public-key cryptography 公钥密码学](https://en.wikipedia.org/wiki/Public-key_cryptography)
3. [Digital signatures 数字签名](https://en.wikipedia.org/wiki/Digital_signature)
4. [Elliptic curve 椭圆曲线](https://en.wikipedia.org/wiki/Elliptic_curve)
5. [Elliptic curve cryptography
   椭圆曲线加密](https://en.wikipedia.org/wiki/Elliptic_curve_cryptography)
6. [ECDSA](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm)
7. [Technical background of Bitcoin addresses
   比特币地址的技术背景](https://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses)
8. [Address 地址](https://en.bitcoin.it/wiki/Address)
9. [Base58 基地58](https://en.bitcoin.it/wiki/Base58Check_encoding)
10. [A gentle introduction to elliptic curve cryptography
    椭圆曲线密码学简介](http://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/)



##  Building Blockchain in Go. Part 6: Transactions 2

18 Sep 2017

> Chinese translations: [by liuchengxu](https://github.com/liuchengxu/blockchain-tutorial/blob/master/content/part-6/transactions-2.md), [by zhangli1](https://zhangli1.gitbooks.io/dummies-for-blockchain/content/)
> 中文翻译：刘成旭、张莉1

### Introduction 导言

In the very first part of this series I said that blockchain is a distributed database. Back then, we decided to skip the “distributed” part and focus on the “database” part. So far, we’ve implemented almost all the things that make a blockchain database. In this post, we’ll cover some mechanisms that were skipped in the previous parts, and in the next part we’ll start working on the distributed nature of blockchain.
在本系列的第一部分，我说区块链是一个分布式数据库。当时，我们决定跳过 "分布式 "部分，专注于 "数据库 "部分。到目前为止，我们已经实现了区块链数据库的几乎所有功能。在这篇文章中，我们将介绍前几部分中跳过的一些机制，下一部分我们将开始研究区块链的分布式特性。

Previous parts: 前几部分

1. [Basic Prototype 基本原型](https://jeiwan.net/posts/building-blockchain-in-go-part-1/)
2. [Proof-of-Work 工作证明](https://jeiwan.net/posts/building-blockchain-in-go-part-2/)
3. [Persistence and CLI 持久性和 CLI](https://jeiwan.net/posts/building-blockchain-in-go-part-3/)
4. [Transactions 1 交易 1](https://jeiwan.net/posts/building-blockchain-in-go-part-4/)
5. [Addresses 地址](https://jeiwan.net/posts/building-blockchain-in-go-part-5/)

> This part introduces significant code changes, so it makes no sense explaining all of them here. Please refer to [this page](https://github.com/Jeiwan/blockchain_go/compare/part_5...part_6#files_bucket) to see all the changes since the last article.
> 本部分引入了重要的代码更改，因此在此无法一一解释。请参阅本页，查看自上一篇文章以来的所有更改。

### Reward 奖励

One tiny thing we skipped in a previous article is rewards for mining. And we already have everything to implement it.
我们在前一篇文章中忽略了一件小事，那就是采矿奖励。而我们已经具备了实现它的一切条件。

The reward is just a coinbase transaction. When a mining node starts mining a new block, it takes transactions from the queue and prepends a coinbase transaction to them. The coinbase transaction’s only output contains miner’s public key hash.
奖励只是 coinbase 交易。当挖矿节点开始挖掘一个新区块时，它会从队列中获取交易，并在其中预置一个币安交易。Coinbase 交易的唯一输出包含矿工的公钥哈希值。

Implementing rewards is as easy as updating the `send` command:
实施奖励就像更新 `send` 命令一样简单：

```go
func (cli *CLI) send(from, to string, amount int) {
    ...
    bc := NewBlockchain()
    UTXOSet := UTXOSet{bc}
    defer bc.db.Close()

    tx := NewUTXOTransaction(from, to, amount, &UTXOSet)
    cbTx := NewCoinbaseTX(from, "")
    txs := []*Transaction{cbTx, tx}

    newBlock := bc.MineBlock(txs)
    fmt.Println("Success!")
}
```

In our implementation, the one who creates a transaction mines the new block, and thus, receives a reward.
在我们的实施过程中，创建交易的人开采新区块，从而获得奖励。

### The UTXO Set UTXO套装

In [Part 3: Persistence and CLI](https://jeiwan.net/posts/building-blockchain-in-go-part-3/) we studied the way Bitcoin Core stores blocks in a database. It was said that blocks are stored in `blocks` database and transaction outputs are stored in `chainstate` database. Let me remind you what the structure of `chainstate` is:
在第三部分：持久性和 CLI 中，我们研究了 Bitcoin Core 在数据库中存储区块的方式。据说，区块存储在 `blocks` 数据库中，交易输出存储在 `chainstate` 数据库中。让我提醒一下 `chainstate` 的结构：

1. `'c' + 32-byte transaction hash -> unspent transaction output record for that transaction`
2. `'B' -> 32-byte block hash: the block hash up to which the database represents the unspent transaction outputs`

Since that article, we’ve already implemented transactions, but we haven’t used the `chainstate` to store their outputs. So, this is what we’re going to do now.
从那篇文章开始，我们已经实现了事务，但还没有使用 `chainstate` 来存储其输出。因此，这就是我们现在要做的。

`chainstate` doesn’t store transactions. Instead, it stores what is called the UTXO set, or the set of unspent transaction outputs. Besides this, it stores “the block hash up to which the database represents the unspent transaction outputs”, which we’ll omit for now because we’re not using block heights (but we’ll implement them in next articles).
`chainstate` 并不存储事务。相反，它存储的是所谓的 UTXO 集，即未使用的事务输出集。除此以外，它还存储了 "数据库表示未用事务输出的块哈希值"，由于我们不使用块高度（但我们会在下一篇文章中实现），所以暂时省略了这个值。

So, why do we want to have the UTXO set?
那么，我们为什么需要UTXO设备呢？

Consider the `Blockchain.FindUnspentTransactions` method we’ve implemented earlier:
请看我们之前实现的 `Blockchain.FindUnspentTransactions` 方法：

```go
func (bc *Blockchain) FindUnspentTransactions(pubKeyHash []byte) []Transaction {
    ...
    bci := bc.Iterator()

    for {
        block := bci.Next()

        for _, tx := range block.Transactions {
            ...
        }

        if len(block.PrevBlockHash) == 0 {
            break
        }
    }
    ...
}
```

The function finds transactions with unspent outputs. Since transactions are stored in blocks, it iterates over each block in the blockchain and checks every transaction in it. As of September 18, 2017, there’re 485,860 blocks in Bitcoin and the whole database takes 140+ Gb of disk space. This means that one has to run a full node to validate transactions. Moreover, validating transactions would require iterating over many blocks.
该函数可以找到有未用输出的交易。由于交易是以区块为单位存储的，因此它会遍历区块链中的每个区块，并检查其中的每笔交易。截至 2017 年 9 月 18 日，比特币共有 485 860 个区块，整个数据库需要 140 多 GB 的磁盘空间。这意味着必须运行一个完整的节点才能验证交易。此外，验证交易需要遍历许多区块。

The solution to the problem is to have an index that stores only unspent outputs, and this is what the UTXO set does: this is a cache that is built from all blockchain transactions (by iterating over blocks, yes, but this is done only once), and is later used to calculate balance and validate new transactions. The UTXO set is about 2.7 Gb as of September 2017.
解决问题的办法是建立一个只存储未用输出的索引，这就是UTXO集的作用：这是一个从所有区块链交易中建立起来的缓存（通过对区块的迭代，没错，但这只做一次），随后用于计算余额和验证新的交易。截至 2017 年 9 月，UTXO 集约为 2.7 Gb。

Alright, let’s think what we need to change to implement the UTXO set. Currently, the following methods are used to find transactions:
好了，让我们想想要实现UTXO 设置需要做些什么改变。目前，我们使用以下方法查找事务：

1. `Blockchain.FindUnspentTransactions` – the main function that finds transactions with unspent outputs. It’s this function where the iteration of all blocks happens.
   `Blockchain.FindUnspentTransactions` - 的主函数，用于查找有未用输出的交易。所有区块的迭代就是在这个函数中进行的。
2. `Blockchain.FindSpendableOutputs` – this function is used when a new transaction is created. If finds the enough number of outputs holding required amount. Uses `Blockchain.FindUnspentTransactions`.
   `Blockchain.FindSpendableOutputs` - 创建新交易时使用该函数。如果找到足够数量的输出，则可以持有所需的金额。使用 。 `Blockchain.FindUnspentTransactions`
3. `Blockchain.FindUTXO` – finds unspent outputs for a public key hash, used to get balance. Uses `Blockchain.FindUnspentTransactions`.
   `Blockchain.FindUTXO` - 查找公钥哈希值的未用输出，用于获取平衡。使用 。 `Blockchain.FindUnspentTransactions`
4. `Blockchain.FindTransaction` – finds a transaction in the blockchain by its ID. It iterates over all blocks until finds it.
   `Blockchain.FindTransaction` - 根据 ID 在区块链中查找交易。它会遍历所有区块，直到找到为止。

As you can see, all the methods iterate over blocks in the database. But we cannot improve all of them for now, because the UTXO set doesn’t store all transactions, but only those that have unspent outputs. Thus, it cannot be used in `Blockchain.FindTransaction`.
如您所见，所有方法都会遍历数据库中的区块。但我们现在还不能对所有方法进行改进，因为 UTXO 集并不存储所有事务，而只存储有未用输出的事务。因此，它不能在 `Blockchain.FindTransaction` 中使用。

So, we want the following methods:
因此，我们需要以下方法：

1. `Blockchain.FindUTXO` – finds all unspent outputs by iterating over blocks.
   `Blockchain.FindUTXO` - 通过对区块进行迭代，找到所有未使用的输出。
2. `UTXOSet.Reindex` — uses `FindUTXO` to find unspent outputs, and stores them in a database. This is where caching happens.
   `UTXOSet.Reindex` - 使用 查找未使用的输出，并将其存储到数据库中。这就是缓存发生的地方。 `FindUTXO`
3. `UTXOSet.FindSpendableOutputs` – analog of `Blockchain.FindSpendableOutputs`, but uses the UTXO set.
   `UTXOSet.FindSpendableOutputs` - 的类似程序，但使用的是UTXO 程序集。 `Blockchain.FindSpendableOutputs`
4. `UTXOSet.FindUTXO` – analog of `Blockchain.FindUTXO`, but uses the UTXO set.
   `UTXOSet.FindUTXO` - 的类似程序，但使用的是UTXO 程序集。 `Blockchain.FindUTXO`
5. `Blockchain.FindTransaction` remains the same.
   `Blockchain.FindTransaction` 保持不变。

Thus, the two most frequently used functions will use the cache from now! Let’s start coding.
因此，最常用的两个函数将使用缓存！让我们开始编码吧。

```go
type UTXOSet struct {
    Blockchain *Blockchain
}
```

We’ll use a single database, but we’ll store the UTXO set in a different bucket. Thus, `UTXOSet` is coupled with `Blockchain`.
我们将使用单个数据库，但会将UTXO 数据集存储在不同的数据桶中。因此， `UTXOSet` 与 `Blockchain` 相耦合。

```go
func (u UTXOSet) Reindex() {
    db := u.Blockchain.db
    bucketName := []byte(utxoBucket)

    err := db.Update(func(tx *bolt.Tx) error {
        err := tx.DeleteBucket(bucketName)
        _, err = tx.CreateBucket(bucketName)
    })

    UTXO := u.Blockchain.FindUTXO()

    err = db.Update(func(tx *bolt.Tx) error {
        b := tx.Bucket(bucketName)

        for txID, outs := range UTXO {
            key, err := hex.DecodeString(txID)
            err = b.Put(key, outs.Serialize())
        }
    })
}
```

This method creates the UTXO set initially. First, it removes the bucket if it exists, then it gets all unspent outputs from blockchain, and finally it saves the outputs to the bucket.
该方法最初创建 UTXO 集。首先，它会删除已存在的输出桶，然后从区块链中获取所有未使用的输出，最后将输出保存到输出桶中。

```
Blockchain.FindUTXO` is almost identical to `Blockchain.FindUnspentTransactions`, but now it returns a map of `TransactionID → TransactionOutputs` pairs.
`Blockchain.FindUTXO` 与 几乎相同，但现在它返回的是 对的映射。 `Blockchain.FindUnspentTransactions` `TransactionID → TransactionOutputs
```

Now, the UTXO set can be used to send coins:
现在，UTXO 套件可以用来发送硬币：

```go
func (u UTXOSet) FindSpendableOutputs(pubkeyHash []byte, amount int) (int, map[string][]int) {
    unspentOutputs := make(map[string][]int)
    accumulated := 0
    db := u.Blockchain.db

    err := db.View(func(tx *bolt.Tx) error {
        b := tx.Bucket([]byte(utxoBucket))
        c := b.Cursor()

        for k, v := c.First(); k != nil; k, v = c.Next() {
            txID := hex.EncodeToString(k)
            outs := DeserializeOutputs(v)

            for outIdx, out := range outs.Outputs {
                if out.IsLockedWithKey(pubkeyHash) && accumulated < amount {
                    accumulated += out.Value
                    unspentOutputs[txID] = append(unspentOutputs[txID], outIdx)
                }
            }
        }
    })

    return accumulated, unspentOutputs
}
```

Or check balance:
或检查余额：

```go
func (u UTXOSet) FindUTXO(pubKeyHash []byte) []TXOutput {
    var UTXOs []TXOutput
    db := u.Blockchain.db

    err := db.View(func(tx *bolt.Tx) error {
        b := tx.Bucket([]byte(utxoBucket))
        c := b.Cursor()

        for k, v := c.First(); k != nil; k, v = c.Next() {
            outs := DeserializeOutputs(v)

            for _, out := range outs.Outputs {
                if out.IsLockedWithKey(pubKeyHash) {
                    UTXOs = append(UTXOs, out)
                }
            }
        }

        return nil
    })

    return UTXOs
}
```

These are slightly modified versions of corresponding `Blockchain` methods. Those `Blockchain` methods are not needed anymore.
这些是相应的 `Blockchain` 方法的略微修改版本。 `Blockchain` 方法已不再需要。

Having the UTXO set means that our data (transactions) are now split into to storages: actual transactions are stored in the blockchain, and unspent outputs are stored in the UTXO set. Such separation requires solid synchronization mechanism because we want the UTXO set to always be updated and store outputs of most recent transactions. But we don’t want to reindex every time a new block is mined because it’s these frequent blockchain scans that we want to avoid. Thus, we need a mechanism of updating the UTXO set:
拥有UTXO集意味着我们的数据（交易）现在被分成两个存储空间：实际交易存储在区块链中，未使用的输出存储在UTXO集中。这种分离需要稳固的同步机制，因为我们希望 UTXO 集始终保持更新，并存储最新交易的输出。但我们不想在每次挖掘新区块时都重新索引，因为我们要避免的正是这种频繁的区块链扫描。因此，我们需要一种更新 UTXO 集的机制：

```go
func (u UTXOSet) Update(block *Block) {
    db := u.Blockchain.db

    err := db.Update(func(tx *bolt.Tx) error {
        b := tx.Bucket([]byte(utxoBucket))

        for _, tx := range block.Transactions {
            if tx.IsCoinbase() == false {
                for _, vin := range tx.Vin {
                    updatedOuts := TXOutputs{}
                    outsBytes := b.Get(vin.Txid)
                    outs := DeserializeOutputs(outsBytes)

                    for outIdx, out := range outs.Outputs {
                        if outIdx != vin.Vout {
                            updatedOuts.Outputs = append(updatedOuts.Outputs, out)
                        }
                    }

                    if len(updatedOuts.Outputs) == 0 {
                        err := b.Delete(vin.Txid)
                    } else {
                        err := b.Put(vin.Txid, updatedOuts.Serialize())
                    }

                }
            }

            newOutputs := TXOutputs{}
            for _, out := range tx.Vout {
                newOutputs.Outputs = append(newOutputs.Outputs, out)
            }

            err := b.Put(tx.ID, newOutputs.Serialize())
        }
    })
}
```

The method looks big, but what it does is quite straightforward. When a new block is mined, the UTXO set should be updated. Updating means removing spent outputs and adding unspent outputs from newly mined transactions. If a transaction which outputs were removed, contains no more outputs, it’s removed as well. Quite simple!
这个方法看起来很大，但做起来却很简单。当开采出一个新区块时，UTXO 集就应该更新。更新意味着从新挖出的交易中移除已耗尽的输出，并添加未耗尽的输出。如果被移除输出的交易不再包含输出，那么它也会被移除。非常简单！

Let’s now use the UTXO set where it’s necessary:
现在，让我们在必要的地方使用UTXO 设置：

```go
func (cli *CLI) createBlockchain(address string) {
    ...
    bc := CreateBlockchain(address)
    defer bc.db.Close()

    UTXOSet := UTXOSet{bc}
    UTXOSet.Reindex()
    ...
}
```

Reindexing happens right after a new blockchain is created. For now, this is the only place where `Reindex` is used, even though it looks excessive here because in the beginning of a blockchain there’s only one block with one transaction, and `Update` could’ve been used instead. But we might need the reindexing mechanism in the future.
新区块链创建后会立即重新索引。目前，这是唯一使用 `Reindex` 的地方，尽管它在这里显得有些多余，因为在区块链的开始阶段，只有一个区块有一笔交易，本可以使用 `Update` 来代替。但我们将来可能需要重新索引机制。

```go
func (cli *CLI) send(from, to string, amount int) {
    ...
    newBlock := bc.MineBlock(txs)
    UTXOSet.Update(newBlock)
}
```

And the UTXO set is updated after a new block is mined.
新区块挖出后，UTXO 集会更新。

Let’s check that it works
让我们检查一下它是否正常工作

```shell
$ blockchain_go createblockchain -address 1JnMDSqVoHi4TEFXNw5wJ8skPsPf4LHkQ1
00000086a725e18ed7e9e06f1051651a4fc46a315a9d298e59e57aeacbe0bf73

Done!

$ blockchain_go send -from 1JnMDSqVoHi4TEFXNw5wJ8skPsPf4LHkQ1 -to 12DkLzLQ4B3gnQt62EPRJGZ38n3zF4Hzt5 -amount 6
0000001f75cb3a5033aeecbf6a8d378e15b25d026fb0a665c7721a5bb0faa21b

Success!

$ blockchain_go send -from 1JnMDSqVoHi4TEFXNw5wJ8skPsPf4LHkQ1 -to 12ncZhA5mFTTnTmHq1aTPYBri4jAK8TacL -amount 4
000000cc51e665d53c78af5e65774a72fc7b864140a8224bf4e7709d8e0fa433

Success!

$ blockchain_go getbalance -address 1JnMDSqVoHi4TEFXNw5wJ8skPsPf4LHkQ1
Balance of '1F4MbuqjcuJGymjcuYQMUVYB37AWKkSLif': 20

$ blockchain_go getbalance -address 12DkLzLQ4B3gnQt62EPRJGZ38n3zF4Hzt5
Balance of '1XWu6nitBWe6J6v6MXmd5rhdP7dZsExbx': 6

$ blockchain_go getbalance -address 12ncZhA5mFTTnTmHq1aTPYBri4jAK8TacL
Balance of '13UASQpCR8Nr41PojH8Bz4K6cmTCqweskL': 4
```

Nice! The `1JnMDSqVoHi4TEFXNw5wJ8skPsPf4LHkQ1` address received reward 3 times:
不错！ `1JnMDSqVoHi4TEFXNw5wJ8skPsPf4LHkQ1` 地址收到 3 次奖励：

1. Once for mining the genesis blocks.
   一次用于开采创世积木。
2. Once for mining the block `0000001f75cb3a5033aeecbf6a8d378e15b25d026fb0a665c7721a5bb0faa21b`.
   一旦用于采矿块 `0000001f75cb3a5033aeecbf6a8d378e15b25d026fb0a665c7721a5bb0faa21b` .
3. And once for mining the block `000000cc51e665d53c78af5e65774a72fc7b864140a8224bf4e7709d8e0fa433 `.
   还有一次用于开采区块 `000000cc51e665d53c78af5e65774a72fc7b864140a8224bf4e7709d8e0fa433 `。

### Merkle Tree 梅克尔树

There’s one more optimization mechanism I’d like to discuss in this post.
在这篇文章中，我还想讨论一个优化机制。

As it was said above, the full Bitcoin database (i.e., blockchain) takes more than 140 Gb of disk space. Because of the decentralized nature of Bitcoin, every node in the network must be independent and self-sufficient, i.e. every node must store a full copy of the blockchain. With many people starting using Bitcoin, this rule becomes more difficult to follow: it’s not likely that everyone will run a full node. Also, since nodes are full-fledged participants of the network, they have responsibilities: they must verify transactions and blocks. Also, there’s certain internet traffic required to interact with other nodes and download new blocks.
如上所述，完整的比特币数据库（即区块链）需要超过 140 Gb 的磁盘空间。由于比特币的去中心化特性，网络中的每个节点都必须是独立和自给自足的，即每个节点都必须存储一份完整的区块链副本。随着越来越多的人开始使用比特币，这一规则变得更加难以遵守：不可能每个人都运行一个完整的节点。另外，由于节点是网络的正式参与者，它们也有责任：它们必须验证交易和区块。此外，与其他节点交互和下载新区块也需要一定的网络流量。

In [the original Bitcoin paper](https://bitcoin.org/bitcoin.pdf) published by Satoshi Nakamoto, there was a solution for this problem: Simplified Payment Verification (SPV). SPV is a light Bitcoin node that doesn’t download the whole blockchain and **doesn’t verify blocks and transactions**. Instead, it finds transactions in blocks (to verify payments) and is linked to a full node to retrieve just necessary data. This mechanism allows having multiple light wallet nodes with running just one full node.
在中本聪最初发表的比特币论文中，有一个解决这个问题的方案：简化支付验证（SPV）。SPV 是一个轻型比特币节点，它不下载整个区块链，也不验证区块和交易。取而代之的是，它在区块中查找交易（以验证支付），并链接到一个完整节点，以检索必要的数据。这种机制允许在运行一个完整节点的情况下拥有多个轻钱包节点。

For SPV to be possible, there should be a way to check if a block contains certain transaction without downloading the whole block. And this is where Merkle tree comes into play.
要使 SPV 成为可能，应该有一种方法可以在不下载整个区块的情况下检查一个区块是否包含某些交易。这就是 Merkle 树发挥作用的地方。

Merkle trees are used by Bitcoin to obtain transactions hash, which is then saved in block headers and is considered by the proof-of-work system. Until now, we just concatenated hashes of each transaction in a block and applied `SHA-256` to them. This is also a good way of getting a unique representation of block transactions, but it doesn’t have benefits of Merkle trees.
梅克尔树被比特币用来获取交易哈希值，然后将其保存在区块头中，并被工作证明系统所考虑。到目前为止，我们只是将区块中每笔交易的哈希值连接起来，然后应用 `SHA-256` 。这也是获得区块交易唯一表示的好方法，但它没有梅克尔树的好处。

Let’s look at a Merkle tree:
让我们来看看梅克尔树：

![Merkle tree diagram](https://jeiwan.net/images/merkle-tree-diagram.png)

A Merkle tree is built for each block, and it starts with leaves (the bottom of the tree), where a leaf is a transaction hash (Bitcoins uses double `SHA256` hashing). The number of leaves must be even, but not every block contains an even number of transactions. In case there is an odd number of transactions, the last transaction is duplicated (in the Merkle tree, not in the block!).
每个区块都会建立一棵默克尔树，它以叶子（树的底部）开始，叶子是交易哈希值（比特币使用双 `SHA256` 哈希值）。叶子的数量必须是偶数，但并不是每个区块都包含偶数个交易。如果交易次数为奇数，最后一笔交易将被重复（在梅克尔树中，而不是在区块中！）。

Moving from the bottom up, leaves are grouped in pairs, their hashes are concatenated, and a new hash is obtained from the concatenated hashes. The new hashes form new tree nodes. This process is repeated until there’s just one node, which is called the root of the tree. The root hash is then used as the unique representation of the transactions, is saved in block headers, and is used in the proof-of-work system.
自下而上，树叶成对分组，它们的哈希值被串联起来，然后从串联的哈希值中得到一个新的哈希值。新的哈希值组成新的树节点。这个过程不断重复，直到只剩下一个节点，即树根。根散列被用作交易的唯一表示，保存在区块头中，并用于工作量证明系统。

The benefit of Merkle trees is that a node can verify membership of certain transaction without downloading the whole block. Just a transaction hash, a Merkle tree root hash, and a Merkle path are required for this.
默克尔树的好处是，节点无需下载整个区块就能验证某些交易的成员身份。这只需要交易哈希值、梅克尔树根哈希值和梅克尔路径。

Finally, let’s write code:
最后，让我们来编写代码：

```go
type MerkleTree struct {
    RootNode *MerkleNode
}

type MerkleNode struct {
    Left  *MerkleNode
    Right *MerkleNode
    Data  []byte
}
```

We start with structs. Every `MerkleNode` keeps data and links to its branches. `MerkleTree` is actually the root node linked to the next nodes, which are in their turn linked to further nodes, etc.
我们从结构体开始。每个 `MerkleNode` 都保存数据并链接到其分支。 `MerkleTree` 实际上是链接到下一个节点的根节点，而下一个节点又链接到更多节点，等等。

Let’s create a new node first:
让我们先创建一个新节点：

```go
func NewMerkleNode(left, right *MerkleNode, data []byte) *MerkleNode {
    mNode := MerkleNode{}

    if left == nil && right == nil {
        hash := sha256.Sum256(data)
        mNode.Data = hash[:]
    } else {
        prevHashes := append(left.Data, right.Data...)
        hash := sha256.Sum256(prevHashes)
        mNode.Data = hash[:]
    }

    mNode.Left = left
    mNode.Right = right

    return &mNode
}
```

Every node contains some data. When a node is a leaf, the data is passed from the outside (a serialized transaction in our case). When a node is linked to other nodes, it takes their data and concatenates and hashes it.
每个节点都包含一些数据。当节点是叶子节点时，数据从外部传递（在我们的例子中是序列化事务）。当一个节点与其他节点链接时，它会获取它们的数据，并对其进行连接和散列。

```go
func NewMerkleTree(data [][]byte) *MerkleTree {
    var nodes []MerkleNode

    if len(data)%2 != 0 {
        data = append(data, data[len(data)-1])
    }

    for _, datum := range data {
        node := NewMerkleNode(nil, nil, datum)
        nodes = append(nodes, *node)
    }

    for i := 0; i < len(data)/2; i++ {
        var newLevel []MerkleNode

        for j := 0; j < len(nodes); j += 2 {
            node := NewMerkleNode(&nodes[j], &nodes[j+1], nil)
            newLevel = append(newLevel, *node)
        }

        nodes = newLevel
    }

    mTree := MerkleTree{&nodes[0]}

    return &mTree
}
```

When a new tree is created, the first thing to ensure is that there is an even number of leaves. After that, `data` (which is an array of serialized transactions) is converted into tree leaves, and a tree is grown from these leaves.
创建一棵新树时，首先要确保有偶数个树叶。之后， `data` （这是一个序列化事务的数组）会被转换成树叶，然后从这些树叶中生长出一棵树。

Now, let’s modify `Block.HashTransactions`, which is used in the proof-of-work system to obtain transactions hash:
现在，让我们修改 `Block.HashTransactions` ，它在工作证明系统中用于获取交易哈希值：

```go
func (b *Block) HashTransactions() []byte {
    var transactions [][]byte

    for _, tx := range b.Transactions {
        transactions = append(transactions, tx.Serialize())
    }
    mTree := NewMerkleTree(transactions)

    return mTree.RootNode.Data
}
```

First, transactions are serialized (using `encoding/gob`), and then they are used to build a Merkle tree. The root of the tree will serve as the unique identifier of block’s transactions.
首先，对交易进行序列化（使用 `encoding/gob` ），然后用它们构建一棵梅克尔树。树根将作为区块交易的唯一标识符。

### P2PKH

There’s one more thing I’d like to discuss in more detail.
还有一件事我想详细谈谈。

As you remember, in Bitcoin there is the *Script* programming language, which is used to lock transaction outputs; and transaction inputs provide data to unlock outputs. The language is simple, and code in this language is just a sequence of data and operators. Consider this example:
大家都还记得，比特币中有一种脚本编程语言，用于锁定交易输出；而交易输入则为解锁输出提供数据。这种语言非常简单，代码只是数据和运算符的序列。请看这个例子

```shell
5 2 OP_ADD 7 OP_EQUAL
5`, `2`, and `7` are data. `OP_ADD` and `OP_EQUAL` are operators. *Script* code is executed from left to right: every piece of data is put into the stack and the next operator is applied to the top stack elements. *Script*’s stack is just a simple FILO (First Input Last Output) memory storage: the first element in the stack is the last to be taken, with every further element being put on the previous one.
`5` `2` `7` `OP_ADD` 和 是运算符。脚本代码从左到右执行：每一个数据都被放入堆栈，下一个运算符应用于堆栈顶部的元素。脚本的堆栈只是一个简单的 FILO（First Input Last Output）内存存储：堆栈中的第一个元素是最后一个被取走的元素，接下来的每一个元素都放在前一个元素上。 `OP_EQUAL
```

Let’s break the execution of the above script into steps:
让我们把上述脚本的执行分成几个步骤：

1. Stack: empty. Script: `5 2 OP_ADD 7 OP_EQUAL`.
   堆栈：空。脚本： `5 2 OP_ADD 7 OP_EQUAL` 。
2. Stack: `5`. Script: `2 OP_ADD 7 OP_EQUAL`.
   堆栈： `5` .脚本： `2 OP_ADD 7 OP_EQUAL` .
3. Stack: `5 2`. Script: `OP_ADD 7 OP_EQUAL`.
   堆栈： `5 2` .脚本： `OP_ADD 7 OP_EQUAL` .
4. Stack: `7`. Script: `7 OP_EQUAL`.
   堆栈： `7` .脚本： `7 OP_EQUAL` .
5. Stack: `7 7`. Script: `OP_EQUAL`.
   堆栈： `7 7` .脚本： `OP_EQUAL` .
6. Stack: `true`. Script: empty.
   堆栈： `true` 。脚本： 空。

```
OP_ADD` takes two elements from the stack, summarizes them, and push the sum into the stack. `OP_EQUAL` takes two elements from the stack and compares them: if they’re equal it pushes `true` to the stack; otherwise it pushes `false`. A result of a script execution is the value of the top stack element: in our case, it’s `true`, which means that the script finished successfully.
`OP_ADD` `OP_EQUAL` 从堆栈中提取两个元素并进行比较：如果两个元素相等，则将 推入堆栈；否则将 推入堆栈。脚本执行的结果就是栈顶元素的值：在我们的例子中，它是 ，这意味着脚本成功完成。 `true` `false` `true
```

Now let’s look at the script that is used in Bitcoin to perform payments:
现在，让我们来看看比特币中用于执行支付的脚本：

```shell
<signature> <pubKey> OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
```

This script is called *Pay to Public Key Hash* (P2PKH), and this is the most commonly used script in Bitcoin. It literally pays to a public key hash, i.e. locks coins with a certain public key. This is **the heart of Bitcoin payments**: there are no accounts, no funds transferring between them; there’s just a script that checks that provided signature and public key are correct.
这种脚本被称为 "支付公钥散列"（P2PKH），是比特币中最常用的脚本。它的字面意思是支付给公钥散列，即用某个公钥锁定币。这就是比特币支付的核心：没有账户，没有账户之间的资金转移；只有一个脚本，检查所提供的签名和公钥是否正确。

The script is actually stored in two parts:
脚本实际上分为两部分存储：

1. The first piece, `<signature> <pubKey>`, is stored in input’s `ScriptSig` field.
   第一部分 `<signature> <pubKey>` 保存在输入的 `ScriptSig` 字段中。
2. The second piece, `OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG` is stored in output’s `ScriptPubKey`.
   第二部分 `OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG` 保存在输出的 `ScriptPubKey` 中。

Thus, it’s outputs that define unlocking logic, and it’s inputs that provide data to unlock outputs. Let’s execute the script:
因此，定义解锁逻辑的是输出，为解锁输出提供数据的是输入。让我们执行脚本：

1. Stack: empty 堆栈：空
   Script: `<signature> <pubKey> OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG` 脚本 `<signature> <pubKey> OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG`
2. Stack: `<signature>` 堆栈 `<signature>`
   Script: `<pubKey> OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG` 脚本 `<pubKey> OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG`
3. Stack: `<signature> <pubKey>` 堆栈 `<signature> <pubKey>`
   Script: `OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG` 脚本 `OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG`
4. Stack: `<signature> <pubKey> <pubKey>` 堆栈 `<signature> <pubKey> <pubKey>`
   Script: `OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG` 脚本 `OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG`
5. Stack: `<signature> <pubKey> <pubKeyHash>` 堆栈 `<signature> <pubKey> <pubKeyHash>`
   Script: `<pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG` 脚本 `<pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG`
6. Stack: `<signature> <pubKey> <pubKeyHash> <pubKeyHash>` 堆栈 `<signature> <pubKey> <pubKeyHash> <pubKeyHash>`
   Script: `OP_EQUALVERIFY OP_CHECKSIG` 脚本 `OP_EQUALVERIFY OP_CHECKSIG`
7. Stack: `<signature> <pubKey>` 堆栈 `<signature> <pubKey>`
   Script: `OP_CHECKSIG` 脚本 `OP_CHECKSIG`
8. Stack: `true` or `false`. Script: empty.
   堆栈： `true` 或 `false` 。脚本：空。

```
OP_DUP` duplicates the top stack element. `OP_HASH160` takes the top stack element and hashes it with `RIPEMD160`; the result is pushed back to the stack. `OP_EQUALVERIFY` compares two top stack elements, and if they’re not equal, interrupts the script. `OP_CHECKSIG` validates the signature of a transaction by hashing the transaction and using `<signature>` and `<pubKey>`. The latter operator is quite complex: it makes a trimmed copy of the transaction, hashes it (because it’s a hash of a transaction that’s signed), and checks that the signature is correct using provided `<signature>` and `<pubKey>`.
`OP_DUP` `OP_HASH160` `RIPEMD160` `OP_EQUALVERIFY` 比较堆栈顶部的两个元素，如果不相等，则中断脚本。 通过对事务进行散列并使用 和 验证事务的签名。后一个运算符相当复杂：它制作一个经过修剪的事务副本，对其进行散列（因为它是已签名事务的散列），然后使用提供的 和 检查签名是否正确。 `OP_CHECKSIG` `<signature>` `<pubKey>` `<signature>` `<pubKey>
```

Having such scripting language allows Bitcoin to be also a smart-contract platform: the language makes possible other payment schemes besides transferring to a single key. For example,
有了这种脚本语言，比特币也可以成为一个智能合约平台：除了向单个密钥转账外，这种语言还可以实现其他支付方案。例如

### Conclusion 结论

And that’s it! We’ve implemented almost all key feature of a blockchain-based cryptocurrency. We have blockchain, addresses, mining, and transactions. But there’s one more thing that gives life to all these mechanisms and makes Bitcoin a global system: consensus. In the next article, we’ll start implementing the “decentralized” part of the blockchain. Stay tuned!
就是这样！我们几乎实现了基于区块链的加密货币的所有关键功能。我们有了区块链、地址、挖矿和交易。但还有一样东西赋予了所有这些机制生命力，并使比特币成为一个全球性系统：共识。在下一篇文章中，我们将开始实现区块链的 "去中心化 "部分。敬请期待！

Links: 链接

1. [Full source codes 完整源代码](https://github.com/Jeiwan/blockchain_go/tree/part_6)
2. [The UTXO Set UTXO套装](https://en.bitcoin.it/wiki/Bitcoin_Core_0.11_(ch_2):_Data_Storage#The_UTXO_set_.28chainstate_leveldb.29)
3. [Merkle Tree 梅克尔树](https://en.bitcoin.it/wiki/Protocol_documentation#Merkle_Trees)
4. [Script 脚本](https://en.bitcoin.it/wiki/Script)
5. [“Ultraprune” Bitcoin Core commit
   "Ultraprune "比特币核心提交](https://github.com/sipa/bitcoin/commit/450cbb0944cd20a06ce806e6679a1f4c83c50db2)
6. [UTXO set statistics UTXO数据集统计](https://statoshi.info/dashboard/db/unspent-transaction-output-set)
7. [Smart contracts and Bitcoin
   智能合约和比特币](https://medium.com/@maraoz/smart-contracts-and-bitcoin-a5d61011d9b1)
8. [Why every Bitcoin user should understand “SPV security”
   为什么每个比特币用户都应该了解 "SPV 安全性"？](https://medium.com/@jonaldfyookball/why-every-bitcoin-user-should-understand-spv-security-520d1d45e0b9)

## Building Blockchain in Go. Part 7: Network

06 Oct 2017

> Chinese translations: [by liuchengxu](https://github.com/liuchengxu/blockchain-tutorial/blob/master/content/part-7/network.md), [by zhangli1](https://zhangli1.gitbooks.io/dummies-for-blockchain/content/)
> 中文翻译：刘成旭、张莉1

### Introduction 导言

So far, we’ve build a blockchain that has all key features: anonymous, secure, and randomly generated addresses; blockchain data storage; Proof-of-Work system; reliable way to store transactions. While these features are crucial, it’s not enough. What makes these features really shine, and what make cryptocurrencies possible, is network. What’s the use of having such blockchain implementation running just on a single computer? What’s the use of those cryptography based features, when there’s just one user? It’s network that make all these mechanism work and be useful.
到目前为止，我们已经构建了一个具备所有关键功能的区块链：匿名、安全、随机生成的地址；区块链数据存储；工作证明系统；可靠的交易存储方式。虽然这些功能至关重要，但还远远不够。真正让这些功能大放异彩，让加密货币成为可能的是网络。仅仅在一台计算机上运行这样的区块链实施方案有什么用？如果只有一个用户，这些基于密码学的功能又有什么用呢？是网络让所有这些机制得以运行并发挥作用。

You can think of those blockchain features as rules, similar to the rules that people establish when they want to live and thrive together. A kind of social arrangements. Blockchain network is a community of programs that follow the same rules, and it’s this following the rules that makes the network alive. Similarly, when people share identical ideas, they become stronger and can together build a better life. If there are people that follow a different set of rules, they’ll live in a separate society (state, commune, etc.). Identically, if there’re blockchain nodes that follow different rules, they’ll form a separate network.
你可以把区块链的这些功能看作是规则，类似于人们想要共同生活和发展时建立的规则。一种社会安排。区块链网络是一个由遵循相同规则的程序组成的社区，正是这种对规则的遵循让网络充满活力。同样，当人们分享相同的想法时，他们会变得更加强大，可以共同建设美好的生活。如果有人遵循不同的规则，他们就会生活在一个独立的社会（国家、公社等）中。同样，如果有遵循不同规则的区块链节点，它们也会形成一个独立的网络。

**This is very important:** without a network and without a majority of nodes sharing identical rules, these rules are useless!
这一点非常重要：没有网络，没有大多数节点共享相同的规则，这些规则就毫无用处！

> DISCLAIMER: Unfortunately, I didn’t have enough time to implement a real P2P network prototype. In this article I’ll demonstrate a most common scenario, that involves nodes of different types. Improving this scenario and making this a P2P network can be a good challenge and practice for you! Also I cannot guarantee that other scenarios besides the one implemented in this article, will work. Sorry!
> 免责声明：很遗憾，我没有足够的时间来实现一个真正的 P2P 网络原型。在本文中，我将演示一个最常见的场景，其中涉及不同类型的节点。改进这个场景并使其成为一个 P2P 网络对你来说是一个很好的挑战和练习！此外，我不能保证除了本文中实现的方案外，其他方案也能正常运行。对不起！

> This part introduces significant code changes, so it makes no sense explaining all of them here. Please refer to [this page](https://github.com/Jeiwan/blockchain_go/compare/part_6...part_7#files_bucket) to see all the changes since the last article.
> 本部分引入了重要的代码更改，因此在此无法一一解释。请参阅本页，查看自上一篇文章以来的所有更改。

### Blockchain Network 区块链网络

Blockchain network is decentralized, which means there’re no servers that do stuff and clients that use servers to get or process data. In blockchain network there are nodes, and each node is a full-fledged member of the network. A node is everything: it’s both a client and a server. This is very important to keep in mind, because it’s very different from usual web applications.
区块链网络是去中心化的，这意味着没有服务器来做事情，也没有客户端使用服务器来获取或处理数据。区块链网络中有节点，每个节点都是网络的正式成员。节点无所不能：它既是客户端，也是服务器。这一点非常重要，因为它与普通的网络应用程序截然不同。

Blockchain network is a P2P (Peer-to-Peer) network, which means that nodes are connected directly to each other. It’s topology is flat, since there are no hierarchy in node roles. Here its schematic representation:
区块链网络是一种 P2P（点对点）网络，即节点之间直接相连。它的拓扑结构是扁平的，因为节点角色没有等级之分。下面是它的示意图：

![P2P Network Scheme](https://jeiwan.net/images/p2p-network.png) ([Business vector created by Dooder - Freepik.com](https://www.freepik.com/dooder))
( 商业矢量由 Dooder 创建 - Freepik.com)

Nodes in such network are more difficult to implement, because they have to perform a lot of operations. Each node must interact with multiple other nodes, it must request other node’s state, compare it with it’s own state, and update its state when it’s outdated.
这种网络中的节点更难实现，因为它们必须执行大量操作。每个节点必须与多个其他节点交互，必须请求其他节点的状态，将其与自己的状态进行比较，并在状态过时时更新自己的状态。

### Node Roles 节点角色

Despite being full-fledged, blockchain nodes can play different roles in the network. Here they are:
尽管区块链节点是完整的，但它们在网络中可以扮演不同的角色。它们是

1. Miner. 矿工
   Such nodes are run on powerful or specialized hardware (like ASIC), and their only goal is to mine new blocks as fast as possible. Miners are only possible in blockchains that use Proof-of-Work, because mining actually means solving PoW puzzles. In Proof-of-Stake blockchains, for example, there’s no mining.
   这些节点在功能强大或专用的硬件（如 ASIC）上运行，它们的唯一目标就是尽可能快地挖掘新区块。只有在使用 "工作证明 "的区块链中才可能出现矿工，因为挖矿实际上意味着解决 "工作证明 "难题。例如，在 "获利证明"（Proof-of-Stake）区块链中，就不存在矿工。
2. Full node. 全节点。
   These nodes validate blocks mined by miners and verify transactions. To do this, they must have the whole copy of blockchain. Also, such nodes perform such routing operations, like helping other nodes to discover each other.
   这些节点验证矿工挖出的区块并验证交易。为此，它们必须拥有整个区块链副本。此外，这些节点还执行路由操作，如帮助其他节点发现彼此。
   It’s very crucial for network to have many full nodes, because it’s these nodes that make decisions: they decide if a block or transaction is valid.
   对于网络来说，拥有许多完整的节点非常重要，因为正是这些节点在做决定：它们决定一个区块或交易是否有效。
3. SPV.
   SPV stands for Simplified Payment Verification. These nodes don’t store a full copy of blockchain, but they still able to verify transactions (not all of them, but a subset, for example, those that were sent to specific address). An SPV node depends on a full node to get data from, and there could be many SPV nodes connected to one full node. SPV makes wallet applications possible: one don’t need to download full blockchain, but still can verify their transactions.
   SPV 代表简化支付验证。这些节点不存储区块链的完整副本，但仍能验证交易（不是全部交易，而是子集，例如发送到特定地址的交易）。SPV 节点依赖完整节点获取数据，一个完整节点可能连接多个 SPV 节点。SPV 使钱包应用成为可能：人们不需要下载完整的区块链，但仍然可以验证他们的交易。

### Network simplification 网络简化

To implement network in our blockchain, we have to simplify some things. The problem is that we don’t have many computers to simulate a network with multiple nodes. We could’ve used virtual machines or Docker to solve this problem, but it could make everything more difficult: you would have to solve possible virtual machine or Docker issues, while my goal is to concentrate on blockchain implementation only. So, we want to run multiple blockchain nodes on a single machine and at the same time we want them to have different addresses. To achieve this we’ll use **ports as node identifiers**, instead of IP addresses. E.g., there will be nodes with addresses: `127.0.0.1:3000`, `127.0.0.1:3001`, `127.0.0.1:3002`, etc. We’ll call the port node ID and use `NODE_ID` environment variable to set them. Thus, you can open multiple terminal windows, set different `NODE_ID`s and have different nodes running.
为了在区块链中实现网络，我们必须简化一些事情。问题是，我们没有足够的计算机来模拟多节点网络。我们本可以使用虚拟机或 Docker 来解决这个问题，但这会让一切变得更加困难：你必须解决虚拟机或 Docker 可能存在的问题，而我的目标只是专注于区块链的实现。因此，我们希望在一台机器上运行多个区块链节点，同时希望它们拥有不同的地址。为此，我们将使用端口作为节点标识符，而不是 IP 地址。例如，节点的地址为 `127.0.0.1:3000` , `127.0.0.1:3001` , `127.0.0.1:3002` 等。我们将把端口称为节点 ID，并使用 `NODE_ID` 环境变量来设置它们。这样，你就可以打开多个终端窗口，设置不同的 `NODE_ID` s 并运行不同的节点。

This approach also requires having different blockchains and wallet files. They now must depend on the node ID and be named like `blockchain_3000.db`, `blockchain_30001.db` and `wallet_3000.db`, `wallet_30001.db`, etc.
这种方法还需要有不同的区块链和钱包文件。它们现在必须取决于节点 ID，并命名为 `blockchain_3000.db` , `blockchain_30001.db` 和 `wallet_3000.db` , `wallet_30001.db` 等。

### Implementation 实施情况

So, what happens when you download, say, Bitcoin Core and run it for the first time? It has to connect to some node to downloaded the latest state of the blockchain. Considering that your computer is not aware of all, or some, Bitcoin nodes, what’s this node?
那么，当你第一次下载并运行 Bitcoin Core 时会发生什么呢？它必须连接到某个节点，下载区块链的最新状态。考虑到你的电脑并不知道所有或某些比特币节点，那么这个节点是什么呢？

Hardcoding a node address in Bitcoin Core would’ve been a mistake: the node could be attacked or shut down, which could result in new nodes not being able to join the network. Instead, in Bitcoin Core, there are [DNS seeds](https://bitcoin.org/en/glossary/dns-seed) hardcoded. These are not nodes, but DNS servers that know addresses of some nodes. When you start a clean Bitcoin Core, it’ll connect to one of the seeds and get a list of full nodes, which it’ll then download the blockchain from.
在 Bitcoin Core 中硬编码节点地址是一个错误：节点可能会被攻击或关闭，从而导致新节点无法加入网络。相反，在 Bitcoin Core 中，有 DNS 种子硬编码。这些种子不是节点，而是知道某些节点地址的 DNS 服务器。当你启动一个干净的 Bitcoin Core 时，它会连接到其中一个种子，并获得完整节点的列表，然后从列表中下载区块链。

In our implementation, there will be centralization though. We’ll have three nodes:
不过，在我们的实施过程中，将实行集中管理。我们将有三个节点：

1. The central node. This is the node all other nodes will connect to, and this is the node that’ll sends data between other nodes.
   中心节点。这是所有其他节点都要连接的节点，也是在其他节点之间发送数据的节点。
2. A miner node. This node will store new transactions in mempool and when there’re enough of transactions, it’ll mine a new block.
   矿工节点。该节点会将新的交易存储到 mempool 中，当有足够多的交易时，它就会挖出一个新区块。
3. A wallet node. This node will be used to send coins between wallets. Unlike SPV nodes though, it’ll store a full copy of blockchain.
   钱包节点。该节点将用于在钱包之间发送硬币。与 SPV 节点不同的是，它将存储一份完整的区块链副本。

#### The Scenario 场景

The goal of this article is to implement the following scenario:
本文的目的是实现以下方案：

1. The central node creates a blockchain.
   中心节点创建区块链。
2. Other (wallet) node connects to it and downloads the blockchain.
   其他（钱包）节点连接到它并下载区块链。
3. One more (miner) node connects to the central node and downloads the blockchain.
   还有一个（矿工）节点连接到中心节点并下载区块链。
4. The wallet node creates a transaction.
   钱包节点创建交易。
5. The miner nodes receives the transaction and keeps it in its memory pool.
   矿工节点接收交易并将其保存在内存池中。
6. When there are enough transactions in the memory pool, the miner starts mining a new block.
   当内存池中有足够多的交易时，矿工就会开始挖掘一个新区块。
7. When a new block is mined, it’s send to the central node.
   新区块挖出后，会发送到中心节点。
8. The wallet node synchronizes with the central node.
   钱包节点与中央节点同步。
9. User of the wallet node checks that their payment was successful.
   钱包节点用户检查付款是否成功。

This is what it looks like in Bitcoin. Even though we’re not going to build a real P2P network, we’re going to implement a real, and the main and most important, use case of Bitcoin.
这就是比特币的样子。尽管我们不会建立一个真正的 P2P 网络，但我们要实现一个真正的，也是比特币最主要、最重要的使用案例。

#### version 版本

Nodes communicate by the means of messages. When a new node is run, it gets several nodes from a DNS seed, and sends them `version` message, which in our implementation will look like this:
节点通过消息进行通信。当一个新节点运行时，它会从 DNS 种子中获取几个节点，并向它们发送 `version` 消息，在我们的实现中，消息的内容如下：

```go
type version struct {
    Version    int
    BestHeight int
    AddrFrom   string
}
```

We have only one blockchain version, so the `Version` field won’t keep any important information. `BestHeight` stores the length of the node’s blockchain. `AddFrom` stores the address of the sender.
我们只有一个区块链版本，因此 `Version` 字段不会保留任何重要信息。 `BestHeight` 存储节点区块链的长度。 `AddFrom` 存储发送者的地址。

What should a node that receives a `version` message do? It’ll respond with its own `version` message. This is a kind of a handshake: no other interaction is possible without prior greeting of each other. But it’s not just politeness: `version` is used to find a longer blockchain. When a node receives a `version` message it checks if the node’s blockchain is longer than the value of `BestHeight`. If it’s not, the node will request and download missing blocks.
收到 `version` 消息的节点应该做什么？它将以自己的 `version` 消息作为回应。这是一种握手：如果不事先互相问候，就无法进行其他交互。但这不仅仅是礼貌问题： `version` 用于寻找更长的区块链。当节点收到 `version` 消息时，它会检查节点的区块链是否长于 `BestHeight` 的值。如果没有，节点将请求并下载缺失的区块。

In order to receive message, we need a server:
为了接收信息，我们需要一个服务器：

```go
var nodeAddress string
var knownNodes = []string{"localhost:3000"}

func StartServer(nodeID, minerAddress string) {
    nodeAddress = fmt.Sprintf("localhost:%s", nodeID)
    miningAddress = minerAddress
    ln, err := net.Listen(protocol, nodeAddress)
    defer ln.Close()

    bc := NewBlockchain(nodeID)

    if nodeAddress != knownNodes[0] {
        sendVersion(knownNodes[0], bc)
    }

    for {
        conn, err := ln.Accept()
        go handleConnection(conn, bc)
    }
}
```

First, we hardcode the address of the central node: every node must know where to connect to initially. `minerAddress` argument specifies the address to receive mining rewards to. This piece:
首先，我们对中心节点的地址进行了硬编码：每个节点都必须知道初始连接到哪里。 `minerAddress` 参数指定了接收挖矿奖励的地址。这一块：

```go
if nodeAddress != knownNodes[0] {
    sendVersion(knownNodes[0], bc)
}
```

Means that if current node is not the central one, it must send `version` message to the central node to find out if its blockchain is outdated.
也就是说，如果当前节点不是中心节点，它必须向中心节点发送 `version` 消息，以了解其区块链是否过时。

```go
func sendVersion(addr string, bc *Blockchain) {
    bestHeight := bc.GetBestHeight()
    payload := gobEncode(version{nodeVersion, bestHeight, nodeAddress})

    request := append(commandToBytes("version"), payload...)

    sendData(addr, request)
}
```

Our messages, on the lower level, are sequences of bytes. First 12 bytes specify command name (“version” in this case), and the latter bytes will contain `gob`-encoded message structure. `commandToBytes` looks like this:
我们的信息在下层是字节序列。前 12 个字节指定命令名称（本例中为 "版本"），后 12 个字节包含 `gob` 编码的报文结构。 `commandToBytes` 看起来像这样：

```go
func commandToBytes(command string) []byte {
    var bytes [commandLength]byte

    for i, c := range command {
        bytes[i] = byte(c)
    }

    return bytes[:]
}
```

It creates a 12-byte buffer and fills it with the command name, leaving rest bytes empty. There’s an opposite function:
它会创建一个 12 字节的缓冲区，并将命令名称填入其中，其余字节留空。还有一个相反的函数：

```go
func bytesToCommand(bytes []byte) string {
    var command []byte

    for _, b := range bytes {
        if b != 0x0 {
            command = append(command, b)
        }
    }

    return fmt.Sprintf("%s", command)
}
```

When a node receives a command, it runs `bytesToCommand` to extract command name and processes command body with correct handler:
节点收到命令后，会运行 `bytesToCommand` 提取命令名，并使用正确的处理程序处理命令体：

```go
func handleConnection(conn net.Conn, bc *Blockchain) {
    request, err := ioutil.ReadAll(conn)
    command := bytesToCommand(request[:commandLength])
    fmt.Printf("Received %s command\n", command)

    switch command {
    ...
    case "version":
        handleVersion(request, bc)
    default:
        fmt.Println("Unknown command!")
    }

    conn.Close()
}
```

Ok, this is what the `version` command handler looks like:
好了，这就是 `version` 命令处理程序的样子：

```go
func handleVersion(request []byte, bc *Blockchain) {
    var buff bytes.Buffer
    var payload verzion

    buff.Write(request[commandLength:])
    dec := gob.NewDecoder(&buff)
    err := dec.Decode(&payload)

    myBestHeight := bc.GetBestHeight()
    foreignerBestHeight := payload.BestHeight

    if myBestHeight < foreignerBestHeight {
        sendGetBlocks(payload.AddrFrom)
    } else if myBestHeight > foreignerBestHeight {
        sendVersion(payload.AddrFrom, bc)
    }

    if !nodeIsKnown(payload.AddrFrom) {
        knownNodes = append(knownNodes, payload.AddrFrom)
    }
}
```

First, we need to decode the request and extract the payload. This is similar to all the handlers, so I’ll omit this piece in the future code snippets.
首先，我们需要解码请求并提取有效负载。这一点与所有处理程序类似，因此我将在以后的代码片段中省略这一部分。

Then a node compares its `BestHeight` with the one from the message. If the node’s blockchain is longer, it’ll reply with `version` message; otherwise, it’ll send `getblocks` message.
然后，节点将自己的 `BestHeight` 与消息中的 进行比较。如果节点的区块链更长，它将回复 `version` 消息；否则，它将发送 `getblocks` 消息。

#### getblocks 获取块

```go
type getblocks struct {
    AddrFrom string
}
```

`getblocks` means “show me what blocks you have” (in Bitcoin, it’s more complex). Pay attention, it doesn’t say “give me all your blocks”, instead it requests a list of block hashes. This is done to reduce network load, because blocks can be downloaded from different nodes, and we don’t want to download dozens of gigabytes from one node.
`getblocks` 的意思是 "告诉我你有哪些区块"（在比特币中，这个意思更复杂）。注意，它并不是说 "给我你所有的区块"，而是请求一个区块哈希值列表。这样做是为了减少网络负荷，因为区块可以从不同的节点下载，我们不想从一个节点下载几十个千兆字节。

Handling the command as easy as:
处理命令就像

```go
func handleGetBlocks(request []byte, bc *Blockchain) {
    ...
    blocks := bc.GetBlockHashes()
    sendInv(payload.AddrFrom, "block", blocks)
}
```

In our simplified implementation, it’ll return **all block hashes**.
在我们的简化实现中，它将返回所有块的哈希值。

#### inv

```go
type inv struct {
    AddrFrom string
    Type     string
    Items    [][]byte
}
```

Bitcoin uses `inv` to show other nodes what blocks or transactions current node has. Again, it doesn’t contain whole blocks and transactions, just their hashes. The `Type` field says whether these are blocks or transactions.
比特币使用 `inv` 向其他节点显示当前节点拥有哪些区块或交易。同样，它不包含整个区块和交易，只包含它们的哈希值。 `Type` 字段说明了这些是区块还是交易。

Handling `inv` is more difficult:
处理 `inv` 则更为困难：

```go
func handleInv(request []byte, bc *Blockchain) {
    ...
    fmt.Printf("Recevied inventory with %d %s\n", len(payload.Items), payload.Type)

    if payload.Type == "block" {
        blocksInTransit = payload.Items

        blockHash := payload.Items[0]
        sendGetData(payload.AddrFrom, "block", blockHash)

        newInTransit := [][]byte{}
        for _, b := range blocksInTransit {
            if bytes.Compare(b, blockHash) != 0 {
                newInTransit = append(newInTransit, b)
            }
        }
        blocksInTransit = newInTransit
    }

    if payload.Type == "tx" {
        txID := payload.Items[0]

        if mempool[hex.EncodeToString(txID)].ID == nil {
            sendGetData(payload.AddrFrom, "tx", txID)
        }
    }
}
```

If blocks hashes are transferred, we want to save them in `blocksInTransit` variable to track downloaded blocks. This allows us to download blocks from different nodes. Right after putting blocks into the transit state, we send `getdata` command to the sender of the `inv` message and update `blocksInTransit`. In a real P2P network, we would want to transfer blocks from different nodes.
如果传输了区块哈希值，我们希望将其保存在 `blocksInTransit` 变量中，以跟踪下载的区块。这样我们就可以从不同节点下载区块。将区块转入传输状态后，我们会立即向 `inv` 消息的发送者发送 `getdata` 命令，并更新 `blocksInTransit` 。在真正的 P2P 网络中，我们希望从不同的节点传输区块。

In our implementation, we’ll never send `inv` with multiple hashes. That’s why when `payload.Type == "tx"` only the first hash is taken. Then we check if we already have the hash in our mempool, and if not, `getdata` message is sent.
在我们的实施过程中，我们永远不会发送带有多个哈希值的 `inv` 。这就是为什么在 `payload.Type == "tx"` 时只提取第一个哈希值。然后，我们会检查内存池中是否已有哈希值，如果没有，就会发送 `getdata` 消息。

#### getdata 获取数据

```go
type getdata struct {
    AddrFrom string
    Type     string
    ID       []byte
}
```

`getdata` is a request for certain block or transaction, and it can contain only one block/transaction ID.
`getdata` 是对某个区块或交易的请求，只能包含一个区块/交易 ID。

```go
func handleGetData(request []byte, bc *Blockchain) {
    ...
    if payload.Type == "block" {
        block, err := bc.GetBlock([]byte(payload.ID))

        sendBlock(payload.AddrFrom, &block)
    }

    if payload.Type == "tx" {
        txID := hex.EncodeToString(payload.ID)
        tx := mempool[txID]

        sendTx(payload.AddrFrom, &tx)
    }
}
```

The handler is straightforward: if they request a block, return the block; if they request a transaction, return the transaction. Notice, that we don’t check if we actually have this block or transaction. This is a flaw :)
处理程序很简单：如果他们请求一个区块，则返回该区块；如果他们请求一个事务，则返回该事务。请注意，我们并没有检查是否真的有这个区块或事务。这是一个缺陷）

#### block and tx 块和 tx

```go
type block struct {
    AddrFrom string
    Block    []byte
}

type tx struct {
    AddFrom     string
    Transaction []byte
}
```

It’s these messages that actually transfer the data.
正是这些信息在实际传输数据。

Handling the `block` message is easy:
处理 `block` 消息非常简单：

```go
func handleBlock(request []byte, bc *Blockchain) {
    ...

    blockData := payload.Block
    block := DeserializeBlock(blockData)

    fmt.Println("Recevied a new block!")
    bc.AddBlock(block)

    fmt.Printf("Added block %x\n", block.Hash)

    if len(blocksInTransit) > 0 {
        blockHash := blocksInTransit[0]
        sendGetData(payload.AddrFrom, "block", blockHash)

        blocksInTransit = blocksInTransit[1:]
    } else {
        UTXOSet := UTXOSet{bc}
        UTXOSet.Reindex()
    }
}
```

When we received a new block, we put it into our blockchain. If there’re more blocks to download, we request them from the same node we downloaded the previous block. When we finally downloaded all the blocks, the UTXO set is reindexed.
当我们收到一个新区块时，就会将其放入我们的区块链中。如果还有更多的区块需要下载，我们就会向下载前一个区块的节点请求下载。当我们最终下载完所有区块后，UTXO 集将被重新索引。

> TODO: Instead of trusting unconditionally, we should validate every incoming block before adding it to the blockchain.
> 待办事项：我们不应该无条件信任，而应该在将每个传入的区块添加到区块链之前对其进行验证。

> TODO: Instead of running UTXOSet.Reindex(), UTXOSet.Update(block) should be used, because if blockchain is big, it’ll take a lot of time to reindex the whole UTXO set.
> TODO: 与其运行 UTXOSet.Reindex()，不如使用 UTXOSet.Update(block)，因为如果区块链很大，重新索引整个 UTXO 集将耗费大量时间。

Handling `tx` messages is the most difficult part:
处理 `tx` 信息是最困难的部分：

```go
func handleTx(request []byte, bc *Blockchain) {
    ...
    txData := payload.Transaction
    tx := DeserializeTransaction(txData)
    mempool[hex.EncodeToString(tx.ID)] = tx

    if nodeAddress == knownNodes[0] {
        for _, node := range knownNodes {
            if node != nodeAddress && node != payload.AddFrom {
                sendInv(node, "tx", [][]byte{tx.ID})
            }
        }
    } else {
        if len(mempool) >= 2 && len(miningAddress) > 0 {
        MineTransactions:
            var txs []*Transaction

            for id := range mempool {
                tx := mempool[id]
                if bc.VerifyTransaction(&tx) {
                    txs = append(txs, &tx)
                }
            }

            if len(txs) == 0 {
                fmt.Println("All transactions are invalid! Waiting for new ones...")
                return
            }

            cbTx := NewCoinbaseTX(miningAddress, "")
            txs = append(txs, cbTx)

            newBlock := bc.MineBlock(txs)
            UTXOSet := UTXOSet{bc}
            UTXOSet.Reindex()

            fmt.Println("New block is mined!")

            for _, tx := range txs {
                txID := hex.EncodeToString(tx.ID)
                delete(mempool, txID)
            }

            for _, node := range knownNodes {
                if node != nodeAddress {
                    sendInv(node, "block", [][]byte{newBlock.Hash})
                }
            }

            if len(mempool) > 0 {
                goto MineTransactions
            }
        }
    }
}
```

First thing to do is to put new transaction in the mempool (again, transactions must be verified before being placed into the mempool). Next piece:
首先要做的是将新事务放入内存池（同样，事务在放入内存池之前必须经过验证）。下一块

```go
if nodeAddress == knownNodes[0] {
    for _, node := range knownNodes {
        if node != nodeAddress && node != payload.AddFrom {
            sendInv(node, "tx", [][]byte{tx.ID})
        }
    }
}
```

Checks whether the current node is the central one. In our implementation, the central node won’t mine blocks. Instead, it’ll forward the new transactions to other nodes in the network.
检查当前节点是否为中心节点。在我们的实现中，中心节点不会挖掘区块。相反，它会将新交易转发给网络中的其他节点。

The next big piece is only for miner nodes. Let’s split it into smaller pieces:
下一大块只针对矿工节点。让我们把它分成小块：

```go
if len(mempool) >= 2 && len(miningAddress) > 0 {
```

`miningAddress` is only set on miner nodes. When there are 2 or more transactions in the mempool of the current (miner) node, mining begins.
`miningAddress` 只在矿工节点上设置。当当前（矿工）节点的内存池中有 2 个或更多交易时，挖矿就开始了。

```go
for id := range mempool {
    tx := mempool[id]
    if bc.VerifyTransaction(&tx) {
        txs = append(txs, &tx)
    }
}

if len(txs) == 0 {
    fmt.Println("All transactions are invalid! Waiting for new ones...")
    return
}
```

First, all transactions in the mempool are verified. Invalid transactions are ignored, and if there are no valid transactions, mining is interrupted.
首先，对 mempool 中的所有交易进行验证。无效交易将被忽略，如果没有有效交易，挖矿将被中断。

```go
cbTx := NewCoinbaseTX(miningAddress, "")
txs = append(txs, cbTx)

newBlock := bc.MineBlock(txs)
UTXOSet := UTXOSet{bc}
UTXOSet.Reindex()

fmt.Println("New block is mined!")
```

Verified transactions are being put into a block, as well as a coinbase transaction with the reward. After mining the block, the UTXO set is reindexed.
经过验证的交易将被放入一个区块，同时币安交易也将获得奖励。挖出区块后，UTXO 集将重新索引。

> TODO: Again, UTXOSet.Update should be used instead of UTXOSet.Reindex
> 提示：同样，应使用 UTXOSet.Update 代替 UTXOSet.Reindex

```go
for _, tx := range txs {
    txID := hex.EncodeToString(tx.ID)
    delete(mempool, txID)
}

for _, node := range knownNodes {
    if node != nodeAddress {
        sendInv(node, "block", [][]byte{newBlock.Hash})
    }
}

if len(mempool) > 0 {
    goto MineTransactions
}
```

After a transaction is mined, it’s removed from the mempool. Every other nodes the current node is aware of, receive `inv` message with the new block’s hash. They can request the block after handling the message.
交易挖完后，会从内存池中删除。当前节点知道的所有其他节点都会收到 `inv` 消息，其中包含新区块的哈希值。处理完消息后，它们就可以申请该区块。

### Result 结果

Let’s play the scenario we defined earlier.
让我们来模拟一下我们之前定义的情景。

First, set `NODE_ID` to 3000 (`export NODE_ID=3000`) in the first terminal window. I’ll use badges like `NODE 3000` or `NODE 3001` before next paragraphs, for you to know what node to perform actions on.
首先，在第一个终端窗口中将 `NODE_ID` 设置为 3000 ( `export NODE_ID=3000` )。我会在接下来的段落前使用 `NODE 3000` 或 `NODE 3001` 这样的徽章，以便你知道要在哪个节点上执行操作。

`NODE 3000`
Create a wallet and a new blockchain:
创建钱包和新区块链：

```shell
$ blockchain_go createblockchain -address CENTREAL_NODE
```

(I’ll use fake addresses for clarity and brevity)
(为简洁明了起见，我使用假地址）

After that, the blockchain will contain single genesis block. We need to save the block and use it in other nodes. Genesis blocks serve as identifiers of blockchains (in Bitcoin Core, the genesis block is hardcoded).
之后，区块链将包含单个创世区块。我们需要保存这个区块，并将其用于其他节点。创世区块是区块链的标识符（在 Bitcoin Core 中，创世区块是硬编码的）。

```shell
$ cp blockchain_3000.db blockchain_genesis.db 
```

`NODE 3001`
Next, open a new terminal window and set node ID to 3001. This will be a wallet node. Generate some addresses with `blockchain_go createwallet`, we’ll call these addresses `WALLET_1`, `WALLET_2`, `WALLET_3`.
接下来，打开一个新的终端窗口，将节点 ID 设置为 3001。这将是一个钱包节点。用 `blockchain_go createwallet` 生成一些地址，我们将这些地址称为 `WALLET_1` , `WALLET_2` , `WALLET_3` 。

`NODE 3000`
Send some coins to the wallet addresses:
向钱包地址发送一些硬币：

```shell
$ blockchain_go send -from CENTREAL_NODE -to WALLET_1 -amount 10 -mine
$ blockchain_go send -from CENTREAL_NODE -to WALLET_2 -amount 10 -mine
```

`-mine` flag means that the block will be immediately mined by the same node. We have to have this flag because initially there are no miner nodes in the network.
`-mine` 标记表示该区块将立即由同一节点进行挖矿。我们必须有这个标志，因为最初网络中没有矿工节点。
Start the node: 启动节点：

```shell
$ blockchain_go startnode
```

The node must be running until the end of the scenario.
节点必须运行到情景结束。

`NODE 3001`
Start the node’s blockchain with the genesis block saved above:
用上面保存的创世区块启动节点的区块链：

```shell
$ cp blockchain_genesis.db blockchain_3001.db
```

Run the node:
运行节点：

```shell
$ blockchain_go startnode
```

It’ll download all the blocks from the central node. To check that everything’s ok, stop the node and check the balances:
它会从中央节点下载所有区块。要检查是否一切正常，请停止节点并检查余额：

```shell
$ blockchain_go getbalance -address WALLET_1
Balance of 'WALLET_1': 10

$ blockchain_go getbalance -address WALLET_2
Balance of 'WALLET_2': 10
```

Also, you can check the balance of the `CENTRAL_NODE` address, because the node 3001 now has its blockchain:
此外，您还可以查看 `CENTRAL_NODE` 地址的余额，因为节点 3001 现在有了自己的区块链：

```shell
$ blockchain_go getbalance -address CENTRAL_NODE
Balance of 'CENTRAL_NODE': 10
```

`NODE 3002`
Open a new terminal window and set its ID to 3002, and generate a wallet. This will be a miner node. Initialize the blockchain:
打开一个新的终端窗口，将其 ID 设置为 3002，然后生成一个钱包。这将是一个矿工节点。初始化区块链：

```shell
$ cp blockchain_genesis.db blockchain_3002.db
```

And start the node:
然后启动节点：

```shell
$ blockchain_go startnode -miner MINER_WALLET
```

`NODE 3001`
Send some coins: 寄些硬币来

```shell
$ blockchain_go send -from WALLET_1 -to WALLET_3 -amount 1
$ blockchain_go send -from WALLET_2 -to WALLET_4 -amount 1
```

`NODE 3002`
Quickly! Switch to the miner node and see it mining a new block! Also, check the output of the central node.
快！切换到矿工节点，查看它正在挖掘新区块！同时，检查中央节点的输出。

`NODE 3001`
Switch to the wallet node and start it:
切换到钱包节点并启动它：

```shell
$ blockchain_go startnode
```

It’ll download the newly mined block!
它会下载新挖出的区块！

Stop it and check balances:
停下来，检查余额：

```shell
$ blockchain_go getbalance -address WALLET_1
Balance of 'WALLET_1': 9

$ blockchain_go getbalance -address WALLET_2
Balance of 'WALLET_2': 9

$ blockchain_go getbalance -address WALLET_3
Balance of 'WALLET_3': 1

$ blockchain_go getbalance -address WALLET_4
Balance of 'WALLET_4': 1

$ blockchain_go getbalance -address MINER_WALLET
Balance of 'MINER_WALLET': 10
```

That’s it! 就是这样！

### Conclusion 结论

This was the final part of the series. I could’ve publish some more posts implementing a real prototype of a P2P network, but I just don’t have time for this. I hope this article answers some of your questions about the Bitcoin technology and raises new ones, for which you can find answers yourself. There are more interesting things hidden in the Bitcoin technology! Good luck!
这是这个系列的最后一部分。我本可以再发表一些文章来实现一个真正的 P2P 网络原型，但我实在没有时间了。我希望这篇文章能回答你关于比特币技术的一些问题，并提出新的问题，你可以自己去寻找答案。比特币技术中还隐藏着更多有趣的东西！祝你好运

P.S. You can start improving the network with implementing the `addr` message, as described in the Bitcoin network protocol (link is below). This is a very important message, because it allows nodes to discover each other. I started implementing it, but haven’t finished!
附注：您可以根据比特币网络协议（链接如下）中的描述，通过实施 `addr` 消息来改进网络。这是一条非常重要的信息，因为它允许节点之间相互发现。我已经开始执行了，但还没有完成！

Links: 链接

1. [Source codes 源代码](https://github.com/Jeiwan/blockchain_go/tree/part_7)
2. [Bitcoin protocol documentation
   比特币协议文档](https://en.bitcoin.it/wiki/Protocol_documentation)
3. [Bitcoin network 比特币网络](https://en.bitcoin.it/wiki/Network)

