---
layout: post
toc: true
title: "设计模式之策略模式"
categories: Code
tags: [设计模式,Cplusplus]
author:
  - Chris Chen
---

 





## 为什么要使用观察者模式

当多个对象依赖一个对象来得到通知时,就需要对对象建立一种通知依赖关系,而使用观察者模式这种面向对象技术可以实现软件架构中的松耦合



## 观察者模式的定义

定义对象中的一对多关系,以便当一个对象改变时,其他对象能得到通知并自动更新



## 具体代码



```c++
/**
 * 
 *FileSplitter.cpp
 *  
 */


//Observer
class IProgress
{
public:
	//Update()
	virtual void DoProgress(float value ) = 0;
	virtual ~IProgress(){}
};


//Concrete Subject:主体对象
class FileSplitter
{
	string m_filePath;
	int m_fileNumber;
	List<IProgress*> m_iprogressList; //抽象通知机制

public:
	FileSplitter(const string& filePath, int fileNumber
		):
	m_filepath(filepath),
	m_fileNumber(fileNumber)
	{

	}


	void split()
	{
		for(int i = 0; i< m_fileNumber;i++)
		{
			float progressvalue = m_fileNumber;
			progressValue = (i+1)/progressvalue;
			onProgress(progressValue)//发送通知	
		}
	}


	//Attach()
	void addIProgress(IProgress* iprogress)
	{
		m_iprogressList.push_bakc(iprogress);
	}

	//Detach()
	void removeIProgress(IProgress* iprogress)
	{
		m_iprogressList.remove(iprogress);
	}

protected:

	//Notify()
	void OnProgress(float value)
	{
		List<IProgress*>::Iterator itor = m_iprogressList.begin();

		//...
		while(itor != m_iprogressList.end())
		{
			(*itor)->DoProgress(value); //更新进度条
			itor++;
		}
	}
}



/**
 * 
 *MainForm.cpp 
 * 
 */

//C++是不推荐多继承的,会带来很多耦合性的问题
//但C++推荐一种多继承,第一个是主的继承类,其他都是接口或是抽象基类





//ConcreteObeserver:具体的观察者
class MainForm: public Form, public IProgress 
{
	TextBox* textFilePath;
	TextBox* textFileNumber;

	IProgress* progressBar;

public:
	void Button_Click()
	{
		string filepath = txtFilePath->getText();
		int number = atoi(textFileNumber->getText().c_str());

		FileSplitter splitter(filePath,number);

		splitter.addIProgress(this);//订阅通知



		splitter.split();
	}



	virtual void DoProgress(float value)
	{
		progressBar->setValue(value);
	} 


}
```



## 总结



* 目标发送通知时,无需指定观察者,通知会自动传播
* 观察者可以自己决定是否需要订阅通知,目标对象对此一无说知
* Observer模式是基于事件的框架中非常常用的一种设计模式









