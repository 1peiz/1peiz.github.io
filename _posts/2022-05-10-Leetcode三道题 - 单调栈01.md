---
layout: post
toc: true
title: "Leetcode三道题 - 单调栈01"
categories: Code
tags: [Leetcode系列]
author:
  - Chris Chen
---



### <a href = "https://leetcode.com/problems/daily-temperatures/description/">739. Daily Temperatures</a>
```c++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& T) 
    {
        //声明一个栈，为单调栈，储存的是元素标号
        stack<int> st;
        //构建一个与T大小一样的数组result并都初始化为0,最后返回这个结果
        vector<int> result(T.size(), 0);
        //遍历T里面的值
        for(int i = 0; i < T.size(); i++)
        {
            //当栈不为空 且 当前遍历到的T数组中的值大于T中标号为栈顶值的元素
            while(!st.empty() && T[i] > T[st.top()])
            {
                //result中标号为栈顶值的元素 被赋值 当前遍历到的标号 - 栈顶元素值
                result[st.top()] = i - st.top();
                //出栈
                st.pop();
            }
            //当遍历到的T中的值小于或等于T[栈顶值]的元素时，将标号入栈
            st.push(i);
        }
        //
        return result;
    }
};·




```


### <a href = "https://leetcode.com/problems/next-greater-element-i/description/">496. Next Greater Element I</a>
```c++
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        stack<int> st;
        vector<int> result(nums1.size(), -1);
        if (nums1.size() == 0) return result;

        unordered_map<int, int> umap; // key:下标元素，value：下标
        for (int i = 0; i < nums1.size(); i++) {
            umap[nums1[i]] = i;
        }
        st.push(0);
        for (int i = 1; i < nums2.size(); i++) {
            if (nums2[i] < nums2[st.top()]) {           // 情况一
                st.push(i);
            } else if (nums2[i] == nums2[st.top()]) {   // 情况二
                st.push(i);
            } else {                                    // 情况三
                while (!st.empty() && nums2[i] > nums2[st.top()]) {
                    if (umap.count(nums2[st.top()]) > 0) { // 看map里是否存在这个元素
                        int index = umap[nums2[st.top()]]; // 根据map找到nums2[st.top()] 在 nums1中的下标
                        result[index] = nums2[i];
                    }
                    st.pop();
                }
                st.push(i);
            }
        }
        return result;
    }
};
```


### <a href = "https://leetcode.com/problems/next-greater-element-ii/description/">503. Next Greater Element II</a>
```c++
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        vector<int> result(nums.size(), -1);
        if (nums.size() == 0) return result;
        stack<int> st;
        for (int i = 0; i < nums.size() * 2; i++) {
            // 模拟遍历两边nums，注意一下都是用i % nums.size()来操作
            while (!st.empty() && nums[i % nums.size()] > nums[st.top()]) {
                result[st.top()] = nums[i % nums.size()];
                st.pop();
            }
            st.push(i % nums.size());
        }
        return result;
    }
};
```